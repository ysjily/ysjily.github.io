<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python复习随笔</title>
    <link href="/2021/01/08/pyfx/"/>
    <url>/2021/01/08/pyfx/</url>
    
    <content type="html"><![CDATA[<ul><li><p>python的浮点运算有些玄学，注意相等比较时加一个精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">3.5</span> - <span class="hljs-number">2.7</span>)<br><span class="hljs-number">0.7999999999999998</span><br></code></pre></td></tr></table></figure></li><li><p>字符串replace返回值为新串，不能直接修改原串。字符串不支持切片更新，但可以直接修改指针指向地址</p></li><li><p>关于set有什么用？去重可以试试</p></li><li><p>有点意思的eval——可以计算表达式的值，可以用作智能类型转化，还可以多个数值型变量的输入。</p></li><li><p>列表分片赋值可以实现数据的插入和批量删除</p></li><li><p>zip可将多个对象对应元素组合成元组。二元列表矩阵配合*解包加上zip可实现矩阵转置。enumerate可以加一个下标返回二元组</p></li><li><p>对象列表排序，用key参数指定lambda函数如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">key = <span class="hljs-keyword">lambda</span> a:a.val<br></code></pre></td></tr></table></figure><p>sorted也可用于字典的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = <span class="hljs-built_in">dict</span>()<br>dic[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span><br>dic[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span><br>dic[<span class="hljs-number">2</span>] = <span class="hljs-number">4</span><br>dic[<span class="hljs-number">5</span>] = <span class="hljs-number">1</span><br>dic[<span class="hljs-number">4</span>] = <span class="hljs-number">3</span><br>newd = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">sorted</span>(dic.items(), key = <span class="hljs-keyword">lambda</span> a: a[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>))<br><span class="hljs-built_in">print</span>(newd)<br></code></pre></td></tr></table></figure></li><li><p>发现字典相关的印象不深，key是键，values是值，items是键值对</p></li><li><p>readline和readlines都会读到行末的换行符，记得去除（忽然想起有个黑科技是strip，可以去除两边的子串，可以去除空格什么的）</p></li><li><p>write,writelines写数据不会换行，自行添加\n</p></li><li><p>用来划分数据的函数，可以把条形图搞成直方图的亚子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ans,_ = np.histogram(hd, <span class="hljs-number">256</span>)<br></code></pre></td></tr></table></figure><p>它有两个返回值，一个是每个区间的个数，一个是每个区间的分界线</p></li><li><p>图例要用legend，并且画图时要加上label</p></li><li><p>继承与派生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,x,y,r</span>):<br>        <span class="hljs-variable language_">self</span>.x=x<br>        <span class="hljs-variable language_">self</span>.y=y<br>        <span class="hljs-variable language_">self</span>.r=r<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> math.pi*<span class="hljs-variable language_">self</span>.r**<span class="hljs-number">2</span><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Cylinder</span>(<span class="hljs-title class_ inherited__">Circle</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,x,y,r,h</span>):<br>        Circle.__init__(<span class="hljs-variable language_">self</span>,x,y,r)<br>        <span class="hljs-variable language_">self</span>.h=h<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">volume</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.area()*<span class="hljs-variable language_">self</span>.h<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>python初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈python函数中一些变量的问题</title>
    <link href="/2020/11/11/py2/"/>
    <url>/2020/11/11/py2/</url>
    
    <content type="html"><![CDATA[<h2 id="局部变量与全局变量的关系"><a href="#局部变量与全局变量的关系" class="headerlink" title="局部变量与全局变量的关系"></a>局部变量与全局变量的关系</h2><p>与c++不同，python中局部与全局的关系很有意思。c++的一部分bug就来自于局部与全局的冲突，当然，好处是可以方便地修改全局变量。而py的主函数和次函数是在不同栈运行的，变量相对独立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuck</span>():<br>    a = <span class="hljs-number">7</span>;b = <span class="hljs-number">8</span><br>    <span class="hljs-built_in">print</span>(a, b)<br>a = <span class="hljs-number">1</span>;b = <span class="hljs-number">2</span><br>fuck()<br><span class="hljs-built_in">print</span>(a, b)<br>&gt;&gt;&gt;<span class="hljs-number">7</span> <span class="hljs-number">8</span><br>&gt;&gt;&gt;<span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>主次函数都定义了a, b，但对其进行操作并不相互影响</p><h2 id="局部与全局之间的桥梁——形参"><a href="#局部与全局之间的桥梁——形参" class="headerlink" title="局部与全局之间的桥梁——形参"></a>局部与全局之间的桥梁——形参</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>拷贝一个相关变量的指针，指向传入前的一个位置（可以是一个数，字符，数据结构等），对指针修改不影响原数据，但对指针所指向的地址修改则会修改其数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuck</span>(<span class="hljs-params">lis</span>):<br>    lis = <span class="hljs-literal">None</span><br>lis = <span class="hljs-built_in">list</span>()<br>lis.append(<span class="hljs-number">2</span>)<br>fuck(lis)<br><span class="hljs-built_in">print</span>(lis)<br>&gt;&gt;&gt;[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>将列表指针指向None，不影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuck</span>(<span class="hljs-params">a, b</span>):<br>    a, b = b, a<br>    <span class="hljs-built_in">print</span>(a, b)<br>a = <span class="hljs-number">6</span>; b = <span class="hljs-number">9</span><br>fuck(a, b)<br><span class="hljs-built_in">print</span>(a, b)<br>&gt;&gt;&gt;<span class="hljs-number">9</span> <span class="hljs-number">6</span><br>&gt;&gt;&gt;<span class="hljs-number">6</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>修改变量指向数值，不影响</p><p>然而，以下修改会对原数值产生影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fuck</span>(<span class="hljs-params">lis</span>):<br>    lis.append(<span class="hljs-number">1</span>)<br>lis = <span class="hljs-built_in">list</span>()<br>lis.append(<span class="hljs-number">2</span>)<br>fuck(lis)<br><span class="hljs-built_in">print</span>(lis)<br>&gt;&gt;&gt;[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>通过指针对其列表中的数据进行修改，全局变量发生改变。</p><h3 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h3><p>顾名思义，不传此参就取默认值，节省码量十分有限，考试或装逼用。没什么说的，过</p><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>一个*，传一堆进去打包成元组</p><p>两个*，传一堆进去打包成字典</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>有可能参数太多我们忘了顺序，那样我们可以直接变量名赋值传参。</p>]]></content>
    
    
    <categories>
      
      <category>python初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python常用内置函数</title>
    <link href="/2020/11/08/py1/"/>
    <url>/2020/11/08/py1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、输入输出函数"><a href="#一、输入输出函数" class="headerlink" title="一、输入输出函数"></a>一、输入输出函数</h3><ol><li><p>print </p><p><strong>print()函数可以同时输出多个字符串，用逗号“,”隔开</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;how&quot;</span>,<span class="hljs-string">&quot;are&quot;</span>,<span class="hljs-string">&quot;you&quot;</span>)<br>hello how are you<br></code></pre></td></tr></table></figure><p><strong>要实现不换行要加end参数表明</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">100</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n =&quot;</span>,n,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">20</span>:<br>        <span class="hljs-keyword">break</span><br>    n += <span class="hljs-number">1</span><br>输出：<br>n = <span class="hljs-number">0</span> n = <span class="hljs-number">1</span> n = <span class="hljs-number">2</span> n = <span class="hljs-number">3</span> n = <span class="hljs-number">4</span> n = <span class="hljs-number">5</span> n = <span class="hljs-number">6</span> n = <span class="hljs-number">7</span> n = <span class="hljs-number">8</span> n = <span class="hljs-number">9</span> n = <span class="hljs-number">10</span> n = <span class="hljs-number">11</span> n = <span class="hljs-number">12</span> n = <span class="hljs-number">13</span> n = <span class="hljs-number">14</span> n = <span class="hljs-number">15</span> n = <span class="hljs-number">16</span> n = <span class="hljs-number">17</span> n = <span class="hljs-number">18</span> n = <span class="hljs-number">19</span> n = <span class="hljs-number">20</span> <br><br></code></pre></td></tr></table></figure><p><strong>格式化输出，%的应用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s=<span class="hljs-string">&#x27;Cui Zhongtian dalao&#x27;</span><br>x=<span class="hljs-built_in">len</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The length of %s is %d&#x27;</span> %(s,x))<br>输出如下：<br>The length of Cui Zhongtian dalao <span class="hljs-keyword">is</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p><strong>最小字段宽度和精度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">PI = <span class="hljs-number">3.141592653</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%10.3f&#x27;</span>%PI)  <span class="hljs-comment">#字段宽10，精度3</span><br><span class="hljs-comment">#     3.142</span><br></code></pre></td></tr></table></figure><p><strong>如需填补</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PI</span> = <span class="hljs-number">3</span>.<span class="hljs-number">141592653</span><br><span class="hljs-attribute">print</span>(&#x27;%<span class="hljs-number">010</span>.<span class="hljs-number">3</span>f&#x27;%PI)  #字段宽<span class="hljs-number">10</span>，精度<span class="hljs-number">3</span><br><span class="hljs-comment">#000003.142</span><br></code></pre></td></tr></table></figure><p><strong>字符串的 format() 方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;We are the &#123;&#125; who say &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;knights&#x27;</span>, <span class="hljs-string">&#x27;Ni&#x27;</span>))<br>We are the knights who say <span class="hljs-string">&quot;Ni!&quot;</span><br></code></pre></td></tr></table></figure><p>花括号和其中的字符（称为格式字段）将替换为传递给 <code>str.format()</code> 方法的对象。花括号中的数字可用来表示传递给 <code>str.format()</code> 方法的对象的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;0&#125; and &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-string">&#x27;eggs&#x27;</span>))<br>spam <span class="hljs-keyword">and</span> eggs<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;1&#125; and &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-string">&#x27;eggs&#x27;</span>))<br>eggs <span class="hljs-keyword">and</span> spam<br></code></pre></td></tr></table></figure><p>如果在 <code>str.format()</code> 方法中使用关键字参数，则使用参数的名称引用它们的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This &#123;food&#125; is &#123;adjective&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(food=<span class="hljs-string">&#x27;spam&#x27;</span>, adjective=<span class="hljs-string">&#x27;absolutely horrible&#x27;</span>))<br>This spam <span class="hljs-keyword">is</span> absolutely horrible.<br></code></pre></td></tr></table></figure><p><strong>制表符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#制表符的写法是\t，作用是对齐表格的各列。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;学号\t姓名\t语文\t数学\t英语&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2017001\t曹操\t99\t\t88\t\t0&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2017002\t周瑜\t92\t\t45\t\t93&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2017008\t黄盖\t77\t\t82\t\t100&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>input函数</p><p>默认为字符串，记得转换</p></li></ol><h3 id="二、其他函数"><a href="#二、其他函数" class="headerlink" title="二、其他函数"></a>二、其他函数</h3><ol><li><p>abs()函数返回数字的绝对值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>( <span class="hljs-built_in">abs</span>(-<span class="hljs-number">45</span>) )                  <span class="hljs-comment"># 返回 45</span><br></code></pre></td></tr></table></figure></li><li><p>chr()函数用一个范围在range(256)内（即0～255）的整数作参数，返回一个对应的ASCII数值，ord()为其逆运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>( <span class="hljs-built_in">chr</span>(<span class="hljs-number">98</span>) )                   <span class="hljs-comment">#  返回：b</span><br><span class="hljs-built_in">print</span>( <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;b&quot;</span>))                   <span class="hljs-comment">#  返回: 98</span><br></code></pre></td></tr></table></figure></li><li><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;3 * 2&#x27;</span>))          <span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure></li><li><p>range()函数生成一个整数序列，不含结尾</p></li><li><p>len()序列元素个数，sum()序列元素和，配合可求平均数</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>python初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AC E#1 - 一道中档题 Factorial</title>
    <link href="/2018/10/30/yang/"/>
    <url>/2018/10/30/yang/</url>
    
    <content type="html"><![CDATA[<p>经过今天的惨痛教训，决定填一下素数筛法这里的坑</p><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>SOL君（炉石主播）和SOL菌（完美信息教室讲师）是好朋友。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>SOL君很喜欢阶乘。而SOL菌很喜欢研究进制。</p><p>这一天，SOL君跟SOL菌炫技，随口算出了n的阶乘。</p><p>SOL菌表示不服，立刻就要算这个数在k进制表示下末尾0的个数。</p><p>但是SOL菌太菜了于是请你帮忙。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们可以知道一个k进制的数如果他末尾有x个0，那么他一定是$k^x$的倍数。</p><p>但由于数字过于的大导致无法直接计算，所以我们要进行质因数分解。</p><p>所以问题转化为在n！的质因子中找k的质因子出现的次数，其中最小的出现次数几位x的值</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1000002</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>(),c = ch;x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) c = ch,ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &amp;&amp; ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span>) x = (x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) x = -x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a&lt;b?a:b;&#125;<br><span class="hljs-type">bool</span> isn[<span class="hljs-number">10000002</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> prime[MAXN],num[MAXN],note[MAXN];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n,k,cnt,tot,sum,tmp,ans = <span class="hljs-number">1LL</span>*MAXN*MAXN;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makep</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    isn[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= <span class="hljs-number">10000002</span>;++ i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!isn[i]) prime[++cnt] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= cnt;++ j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(prime[j]*i &gt; <span class="hljs-number">10000002</span>) <span class="hljs-keyword">break</span>;<br>            isn[prime[j]*i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">makep</span>();<br>    <span class="hljs-built_in">read</span>(n),<span class="hljs-built_in">read</span>(k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= cnt &amp;&amp; k != <span class="hljs-number">1</span>;++ i)<br>    &#123; <br>        <span class="hljs-keyword">if</span>(prime[i] &gt; n) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(k%prime[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            note[++tot] = prime[i];<br>            <span class="hljs-keyword">while</span>(k%prime[i] == <span class="hljs-number">0</span>)<br>&#123;<br>                k /= prime[i];<br>                num[tot] ++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= tot;++ i)<br>    &#123;<br>        tmp = n,sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tmp)<br>&#123;<br>            tmp /= note[i];<br>            sum += tmp;<br>        &#125;<br>        ans = <span class="hljs-built_in">Min</span>(ans,sum/num[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">1LL</span>*MAXN*MAXN) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>铺地毯</title>
    <link href="/2018/10/27/carpet/"/>
    <url>/2018/10/27/carpet/</url>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>上午想到了一半，没有想到用更好的办法O(1)求n-1个矩形的并，就gg掉了。</p><p>我们考虑用前缀和与后缀和优化此问题。</p><p>首先对于n个矩形的并我们可以扫一遍求出来。</p><p>然后对于n - 1个矩形的并我们可以预处理出前缀矩形的并和后缀矩形的并，枚举哪个矩形不用，然后将它前缀的并与它后缀的并再并起来就是这n - 1个矩形的并辣。</p><p>然而还没完，我们发现这n -1个矩形的并包含n个矩形的并，所以我们要减去。</p><p>然后加起来？对！可以直接加起来。我们可以举个栗子。</p><p><img src="https://s1.ax1x.com/2018/10/27/ic9I2t.png"></p><p>我们可以发现，这两个n-1的并的交正是我们要减去的那个n个矩形的并，那么我们可以推广得到，对于其余情况也是如此</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> LL inf = <span class="hljs-number">0x7fffffff</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br>LL x1, x2, y1, y2;<br>&#125;;ss a[N], sum1[N], sum2[N];<br>LL p, q;<br><span class="hljs-type">int</span> n, T;<br>LL ans;<br><span class="hljs-function">ss <span class="hljs-title">merge</span><span class="hljs-params">(ss a, ss b)</span></span><br><span class="hljs-function"></span>&#123;<br>a.x1 = <span class="hljs-built_in">max</span>(a.x1, b.x1);<br>a.y1 = <span class="hljs-built_in">max</span>(a.y1, b.y1);<br>a.x2 = <span class="hljs-built_in">min</span>(a.x2, b.x2);<br>a.y2 = <span class="hljs-built_in">min</span>(a.y2, b.y2);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">S</span><span class="hljs-params">(ss a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a.x2 &lt;= a.x1 || a.y2 &lt;= a.y1) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> (a.x2 - a.x1) * (a.y2 - a.y1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check1</span><span class="hljs-params">(LL &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>a = <span class="hljs-built_in">max</span>(a, <span class="hljs-number">0ll</span>);<br>a = <span class="hljs-built_in">min</span>(p, a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check2</span><span class="hljs-params">(LL &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>a = <span class="hljs-built_in">max</span>(a, <span class="hljs-number">0ll</span>);<br>a = <span class="hljs-built_in">min</span>(q, a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;carpet.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;carpet.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(sum1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sum1));<br><span class="hljs-built_in">memset</span>(sum2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sum2));<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%d&quot;</span>, &amp;p, &amp;q, &amp;n);<br>sum1[<span class="hljs-number">0</span>].x2 = sum1[<span class="hljs-number">0</span>].y2 = sum2[n + <span class="hljs-number">1</span>].x2 = sum2[n + <span class="hljs-number">1</span>].y2 = inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;a[i].x1, &amp;a[i].y1, &amp;a[i].x2, &amp;a[i].y2);<br><span class="hljs-built_in">check1</span>(a[i].x1);<span class="hljs-built_in">check1</span>(a[i].x2);<br><span class="hljs-built_in">check2</span>(a[i].y1);<span class="hljs-built_in">check2</span>(a[i].y2);<br>sum1[i] = <span class="hljs-built_in">merge</span>(sum1[i - <span class="hljs-number">1</span>], a[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>; --i)<br>sum2[i] = <span class="hljs-built_in">merge</span>(sum2[i + <span class="hljs-number">1</span>], a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>&#123;<br>ss b = <span class="hljs-built_in">merge</span>(sum1[i - <span class="hljs-number">1</span>], sum2[i + <span class="hljs-number">1</span>]);<br>ans += <span class="hljs-built_in">S</span>(b);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">S</span>(b) != <span class="hljs-number">0</span>) ans -= <span class="hljs-built_in">S</span>(sum1[n]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans + <span class="hljs-built_in">S</span>(sum1[n]));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前缀和</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串折叠</title>
    <link href="/2018/10/26/zfczd/"/>
    <url>/2018/10/26/zfczd/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>折叠的定义如下：</p><ol><li>一个字符串可以看成它自身的折叠。记作S &#x3D; S</li><li>X(S)是X(X&gt;1)个S连接在一起的串的折叠。记作X(S) &#x3D; SSSS…S(X个S)。</li><li>如果A &#x3D; A’, B &#x3D; B’，则AB &#x3D; A’B’ 例如，因为3(A) &#x3D; AAA, 2(B) &#x3D; BB，所以3(A)C2(B) &#x3D; AAACBB，而2(3(A)C)2(B) &#x3D; AAACAAACBB</li></ol><p>给一个字符串，求它的最短折叠。例如AAAAAAAAAABABABCCD的最短折叠为：9(A)3(AB)CCD。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然区间dp，我们用f[i][j]表示将i到j的字符串折叠得到的最短长度。</p><p>考虑转移</p><ol><li>套路转移：$f[i][j] &#x3D; f[i][k] + f[k + 1][j]$</li><li>如果前面一段是后面一段的重复，那么$f[i][j] &#x3D;f[k + 1][j] + 2 + cal(len &#x2F; (j - k))$，其中cal为求这个数的位数</li></ol><p>那么代码易得</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">char</span> str[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>((r - l + <span class="hljs-number">1</span>) % (y - x + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l;i &lt;= r; ++i)<br><span class="hljs-keyword">if</span>(str[i] != str[x + ((i - l) % (y - x + <span class="hljs-number">1</span>))]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(a)<br>&#123;<br>tot++;<br>a /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str + <span class="hljs-number">1</span>);<br>n = <span class="hljs-built_in">strlen</span>(str + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i) f[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>;l &lt;= n; ++l)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i + l&lt;= n; ++i)<br> &#123;<br> <span class="hljs-type">int</span> j = i + l;<br> f[i][j] = l + <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt;= j - <span class="hljs-number">1</span>; ++k)<br> &#123;<br> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="hljs-number">1</span>][j]);<br> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(i, k, k + <span class="hljs-number">1</span>, j))<br> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[k + <span class="hljs-number">1</span>][j] + <span class="hljs-number">2</span> + <span class="hljs-built_in">cal</span>((l + <span class="hljs-number">1</span>) / (j - k)));<br> &#125;<br> &#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>狡猾的商人</title>
    <link href="/2018/10/26/jh/"/>
    <url>/2018/10/26/jh/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了n个月以来的收入情况，其中第i 个月的收入额为Ai(i&#x3D;1,2,3…n-1,n)， 。当 Ai大于0时表示这个月盈利Ai 元，当 Ai小于0时表示这个月亏损Ai 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。 刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。 现在，刁姹总共偷看了m次账本，当然也就记住了m段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们得到n个式子$\sum A_i &#x3D; w(s &lt;&#x3D; i &lt;&#x3D; t)$，但我们发现这样无法进行建模，于是我们转化成$sum[t] - sum[s- 1] &#x3D; w$。</p><p>等于的差分约束？</p><p>其实就是变一下，变成$sum[t] - sum[s- 1] &gt;&#x3D; w$和$sum[t] - sum[s - 1] &lt;&#x3D; w$即可，然后就是一个差分约束的板子题了</p><p>顺便讲讲差分约束：对于一个不等式:$u - v &lt;&#x3D; w$我们发现与最短路松弛操作$dis[v] - dis[u] &lt;&#x3D; w$特别相似，于是我们可以通过跑最长路来检验整个差分约束系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br>    <span class="hljs-type">int</span> next, to, val;<br>&#125;;ss data[N];<br><span class="hljs-type">int</span> T, n, m, p, flag;<br><span class="hljs-type">int</span> head[N], dis[N], vis[N], used[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(data));<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(head));<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used));<br>    p = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    data[++p].next = head[a];<br>    data[p].to = b;<br>    data[p].val = c;<br>    head[a] = p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; ++i) dis[i] = <span class="hljs-number">-0x3f3f3f3f</span>;<br>    dis[a] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt;Q;<br>    Q.<span class="hljs-built_in">push</span>(a);<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">front</span>();Q.<span class="hljs-built_in">pop</span>();<br>        used[x] = <span class="hljs-number">0</span>;vis[x] ++;<br>        <span class="hljs-keyword">if</span>(vis[x] == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[x];i;i = data[i].next)<br>        &#123;<br>            <span class="hljs-type">int</span> v = data[i].to;<br>            <span class="hljs-keyword">if</span>(dis[v] &lt; dis[x] + data[i].val)<br>            &#123;<br>                dis[v] = dis[x] + data[i].val;<br>                <span class="hljs-keyword">if</span>(!used[v])<br>                &#123;<br>                    used[v] = <span class="hljs-number">1</span>;<br>                    Q.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-built_in">Init</span>();<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> s, t, w;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;w);<br>            <span class="hljs-built_in">add</span>(s - <span class="hljs-number">1</span>, t , w);<span class="hljs-built_in">add</span>(t, s - <span class="hljs-number">1</span>, -w);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; ++i)<br>         <span class="hljs-keyword">if</span>(!vis[i])<br>         &#123;<br>         <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">spfa</span>(i))<br>         &#123;<br>         flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br>         &#125;<br>         &#125;<br>         <br>         <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;false\n&quot;</span>);<br>         <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;true\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>最短路</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>营业额统计</title>
    <link href="/2018/10/26/yye/"/>
    <url>/2018/10/26/yye/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Tiger最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。</p><p>Tiger拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：</p><p>当最小波动值越大时，就说明营业情况越不稳定。</p><p>而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助Tiger来计算这一个值。</p><p>第一天的最小波动值为第一天的营业额。</p><p>该天的最小波动值&#x3D;min{|该天以前某一天的营业额-该天营业额|}。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本来之前是用splay写的，结果死活写不过，wa了两个点……</p><p>今天又看见这道题，结果忘了splay，怎么办？</p><p>那就用set吧23333，然后就是个裸的stl的经典应用了。</p><p>set是个好东西啊！挂一个<a href="https://blog.csdn.net/yas12345678/article/details/52601454">链接</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>set&lt;ll&gt; S;<br>set&lt;ll&gt;::iterator s1;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;0\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br>    ll ans=<span class="hljs-number">0</span>;<br>    n--;<br>    <span class="hljs-type">int</span> p;cin&gt;&gt;p;S.<span class="hljs-built_in">insert</span>(p);<br>    ans=p;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>        cin&gt;&gt;p;<br>        s1=S.<span class="hljs-built_in">lower_bound</span>(p);<br>        ll t = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">if</span> (s1!=S.<span class="hljs-built_in">end</span>())<br>            t=<span class="hljs-built_in">min</span>(t,<span class="hljs-built_in">abs</span>((*s1)-p) );<br>        <span class="hljs-keyword">if</span> (s1!=S.<span class="hljs-built_in">begin</span>())<br>            t=<span class="hljs-built_in">min</span>(t,<span class="hljs-built_in">abs</span>( (*--s1)-p) );<br>        ans+=t;<br>        S.<span class="hljs-built_in">insert</span>(p);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>降雨量</title>
    <link href="/2018/10/26/rain/"/>
    <url>/2018/10/26/rain/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们常常会说这样的话：“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意Y&lt;Z&lt;X，Z年的降雨量严格小于X年。例如2002，2003，2004和2005年的降雨量分别为4920，5901，2832和3890，则可以说“2005年是自2003年以来最多的”，但不能说“2005年是自2002年以来最多的”由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>被这个毒瘤题卡了一个多小时，情况有点复杂，讨论了好久。</p><p>本题的要求可以化为，对于x是y以来降雨量最大的一年，可知$w[y] &gt; w[x] &gt; max(w[y+1] \rightarrow w[x - 1])$</p><p>我们对于已知的降雨量建一棵线段树来维护区间最大值，方便我们进行查询。</p><p>然后我们进行讨论</p><p>如果</p><ol><li><p>左端点已知且小于中间的最大值</p></li><li><p>右端点已知且小于中间的最大值</p></li><li><p>左右端点已知且左端点值小于右端点值</p></li></ol><p>那么判断为flase</p><p>其余如果左右中有一方不确定，那么必定为maybe</p><p>剩下的情况就为true</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lson rt&lt;&lt;1, l, mid</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rson rt&lt;&lt;1|1, mid + 1, r</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> Y[N], X[N], b[N], tree[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> rt)</span></span><br><span class="hljs-function"></span>&#123;<br>tree[rt] = <span class="hljs-built_in">max</span>(tree[rt&lt;&lt;<span class="hljs-number">1</span>], tree[rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l == r)<br>&#123;<br>tree[rt] = X[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(lson);<span class="hljs-built_in">build</span>(rson);<br><span class="hljs-built_in">up</span>(rt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> rt, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y) <br>&#123;<br><span class="hljs-keyword">return</span> tree[rt];<br>&#125;<br><span class="hljs-keyword">if</span>(l &gt; y || r &lt; x) <span class="hljs-keyword">return</span> -inf;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">query</span>(lson, x, y), <span class="hljs-built_in">query</span>(rson, x, y));<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;Y[i], &amp;X[i]);<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>&#123;<br><span class="hljs-type">int</span> l, r, x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>x = <span class="hljs-built_in">lower_bound</span>(Y + <span class="hljs-number">1</span>, Y + <span class="hljs-number">1</span> + n, l) - Y;<br>y = <span class="hljs-built_in">lower_bound</span>(Y + <span class="hljs-number">1</span>, Y + <span class="hljs-number">1</span> + n, r) - Y;<br><span class="hljs-type">int</span> fll = (Y[x] == l), flr = (Y[y] == r), flm = (r - l) == (y - x);<br><span class="hljs-keyword">if</span>(!fll) x--;<br><br><span class="hljs-type">int</span> maxn = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>((fll &amp;&amp; X[x] &lt;= maxn) || (flr &amp;&amp; X[y] &lt;= maxn) || (flr &amp;&amp; fll &amp;&amp; X[x] &lt;= X[y])) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;false\n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!flm || !fll || !flr) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maybe\n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;true\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>线段树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快递方案</title>
    <link href="/2018/10/24/kdfw/"/>
    <url>/2018/10/24/kdfw/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有m点 (1, 2, …, m)，因此「飞奔」仅先行采购了三辆货車并聘用了三名司机，每天早上分别从收件地点 「1」, 「2」 及 「3」出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。</p><p>为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。</p><p>如下面范例二(收件公司地点依序为： 4 2 4 1 5 4 3 2 1)所示，虽然司机1一开始就已经在收件地点「1」了，但是他却不能先把后面第四个登记的公司（地点「1」）邮件先收了再前往第一、第二、或第三个登记收件地点（地点「4」,「2」,「4」）收件。但是如果前三个登记收件的服务是由司机2或3來负责，则司机1就可以在地点「1」收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是說，最佳收件方式也有可能是只需出动一或兩辆车去收货。请写一个程序來帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>语文阅读题，读了好久，题意就是给你一堆邮件，让你用3个人按顺序去取，求最小的耗油量。</p><p>先想一个最傻的状态，$f[i][j][k][l]$表示我们送了钱i个快递，这三个人分别在i,j,k时最小的耗油量。我们发现时空复杂度都布星啊。</p><p>考虑如何优化，首先我们发现i这一维是可以滚的，然后我们又发现这三个人一定会有一个在上一个任务的位置，所以我们可以通过枚举来省掉一维，所以时空复杂度就可过啦！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">2</span>][<span class="hljs-number">205</span>][<span class="hljs-number">205</span>],a[<span class="hljs-number">205</span>][<span class="hljs-number">205</span>];<br><span class="hljs-type">int</span> m,last,p,c,ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) a[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">60</span>,<span class="hljs-built_in">sizeof</span>(f));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>    last=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (c=<span class="hljs-number">1</span>;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p)!=EOF;c^=<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(f[c],<span class="hljs-number">60</span>,<span class="hljs-built_in">sizeof</span>(f[c]));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                <span class="hljs-keyword">if</span> (f[<span class="hljs-number">1</span>-c][i][j]&lt;<span class="hljs-number">1e+9</span>)<br>                &#123;<br>                    f[c][j][last]=<span class="hljs-built_in">min</span>(f[c][j][last],f[<span class="hljs-number">1</span>-c][i][j]+a[i][p]);<br>                    f[c][i][last]=<span class="hljs-built_in">min</span>(f[c][i][last],f[<span class="hljs-number">1</span>-c][i][j]+a[j][p]);<br>                    f[c][i][j]=<span class="hljs-built_in">min</span>(f[c][i][j],f[<span class="hljs-number">1</span>-c][i][j]+a[last][p]);<br>                &#125;<br>        last=p;<br>    &#125;<br>    ans=<span class="hljs-number">1500000000</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) ans=<span class="hljs-built_in">min</span>(ans,f[c^<span class="hljs-number">1</span>][i][j]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>部落划分</title>
    <link href="/2018/10/24/blhf/"/>
    <url>/2018/10/24/blhf/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。</p><p>不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：</p><p>对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先容易看到最近的最远，可以想到二分一个距离，然后用并查集来判断即可。</p><p>然而我们要看到一个本质的问题，我们用一些边将点连成k个连通块，要使这些边最长的尽可能短，想到了什么呢？瓶颈路！于是我们可以用最小生成树来解决这个问题，我们先把边排个序，然后依次加边。当我们把点合成了k个连通块时，那么下一条在两个连通块之间的边就是答案。</p><p>是不是很巧妙啊。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br><span class="hljs-type">double</span> x, y;<br>&#125;;ss data[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bian</span>&#123;<br><span class="hljs-type">int</span> u, v;<br><span class="hljs-type">double</span> w;<br>&#125;;bian edge[N * N];<br><span class="hljs-type">int</span> n, k, cnt;<br><span class="hljs-type">int</span> fa[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(bian a, bian b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((data[a].x - data[b].x) * (data[a].x - data[b].x) + (data[a].y - data[b].y) * (data[a].y - data[b].y));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(fa[a] == a) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">return</span> fa[a] = <span class="hljs-built_in">find</span>(fa[a]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kru</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tot = n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i) fa[i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= cnt; ++i)<br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(edge[i].u), b = <span class="hljs-built_in">find</span>(edge[i].v);<br><span class="hljs-keyword">if</span>(a != b)<br>&#123;<br>fa[a] = b;<br>tot--;<br>&#125;<br><span class="hljs-keyword">if</span>(tot == k - <span class="hljs-number">1</span>) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, edge[i].w);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>, &amp;data[i].x, &amp;data[i].y);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;j &lt;= n; ++j)<br>  edge[++cnt].u = i, edge[cnt].v = j, edge[cnt].w = <span class="hljs-built_in">getd</span>(i, j);<br><span class="hljs-built_in">sort</span>(edge + <span class="hljs-number">1</span>, edge + <span class="hljs-number">1</span> + cnt, cmp);<br><span class="hljs-built_in">kru</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>生成树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逛公园</title>
    <link href="/2018/10/23/park/"/>
    <url>/2018/10/23/park/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>策策同学特别喜欢逛公园。公园可以看成一张N个点M条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口，N号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。</p><p>策策每天都会去逛公园，他总是从1号点进去，从NN号点出来。</p><p>策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果1号点 到NN号点的最短路长为d，那么策策只会喜欢长度不超过d + K的路线。</p><p>策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？</p><p>为避免输出过大，答案对P取模。</p><p>如果有无穷多条合法的路线，请输出-1。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>去年写这个题时就写了个最短路计数结果多组数据没有清空图0分滚粗QAQ。</p><p>想一想dp去哪儿了？这个有向图像不像个dp？</p><p>我们用$f[i][j]$表示到了i这个点与最短路相差j时的方案数，我们设u点为i的前驱，v为u到i的边权，dis[i]为终点到i点的最短路径。那么转移就是$f[i][j] &#x3D; \sum f[u][j - v + dis[u] - dis[i]]$，然后用记搜搞一下就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br><span class="hljs-type">int</span> next, to, val;<br>&#125;;ss data[M];<br><span class="hljs-type">int</span> n, m, k, mod, T, p, flag, ans;<br><span class="hljs-type">int</span> dis[N], head[N], a[M], b[M], c[M];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">55</span>], g[N][<span class="hljs-number">55</span>], used[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>data[++p].next = head[a];<br>data[p].to = b;<br>data[p].val = c;<br>head[a] = p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(data, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(data));<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(f));<br>ans = <span class="hljs-number">0</span>; flag = <span class="hljs-number">0</span>;p = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i) dis[i] = <span class="hljs-number">0x3f3f3f3f</span>;<br>dis[n] = <span class="hljs-number">0</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt;Q;<br>Q.<span class="hljs-built_in">push</span>(n);<br><span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> x = Q.<span class="hljs-built_in">front</span>();Q.<span class="hljs-built_in">pop</span>();<br>used[x] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[x];i;i = data[i].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[i].to;<br><span class="hljs-keyword">if</span>(dis[v] &gt; dis[x] + data[i].val)<br>&#123;<br>dis[v] = dis[x] + data[i].val;<br><span class="hljs-keyword">if</span>(!used[v])<br>&#123;<br>used[v] = <span class="hljs-number">1</span>;<br>Q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> change)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(g[a][change])<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(f[a][change] != - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> f[a][change];<br>g[a][change] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[a];i;i = data[i].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[i].to;<br><span class="hljs-type">int</span> t = change + dis[a] - dis[v] - data[i].val;<br><span class="hljs-keyword">if</span>(t &gt; k || t &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>sum = (sum + <span class="hljs-built_in">dfs</span>(v, t)) % mod;<br><span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>g[a][change] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(a == n &amp;&amp; change == <span class="hljs-number">0</span>) sum++;<br>f[a][change] = sum;<br><span class="hljs-keyword">return</span> f[a][change];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;park.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;park.out&quot;, &quot;w&quot;, stdout);</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;mod);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a[i], &amp;b[i], &amp;c[i]);<br><span class="hljs-built_in">add</span>(b[i], a[i], c[i]);<br>&#125;<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br><span class="hljs-built_in">add</span>(a[i], b[i], c[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= k; ++i)<br>&#123;<br><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g));<br>ans = (ans + <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, i)) % mod;<br>&#125;<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>最短路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路，记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度</title>
    <link href="/2018/10/23/complexity/"/>
    <url>/2018/10/23/complexity/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p><p>A++语言的循环结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">F i x y<br>    循环体<br>E<br></code></pre></td></tr></table></figure><p>其中F i x y表示新建变量 i（变量 i 不可与未被销毁的变量重名）并初始化为 x， 然后判断 i 和 y 的大小关系，若 i 小于等于 y 则进入循环，否则不进入。每次循环结束后 ii 都会被修改成 i +1，一旦 i 大于 y 终止循环。</p><p>x 和 y 可以是正整数（x 和 y 的大小关系不定）或变量 n。n 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。</p><p>“E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。</p><p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>去年被这个卡了很久，还是没有写出来（窝还是太菜了），结果得知有位兄弟全部输出yes水了30分差点把我气死。</p><p>一直给我留下这个心结，所以我一直没有改它，我希望能在能力足够时在考试时战胜它，结果写出正解后定义time变量CE了（哇的一声哭粗来）</p><p>由于后定义的循环会先跳出，所以我们考虑用一个栈来维护，每一个位置存储他用的变量字符，他的时间复杂度，和计算到他那里的时候的答案。</p><p>然后就很简单了，我们每加入一个循环，就计算他的时间复杂度，将他所用的变量打上标记，如果已有标记就判断无解。再加上前面的答案来算出新的答案，如果出栈就清掉栈顶的变量名。</p><p>思路清晰后就很好写了，注意字符串的读入，可以用个类似于快读的东西来搞一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> time tim</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> sj, ans;<br>&#125;;ss stack[<span class="hljs-number">120</span>];<br><span class="hljs-type">int</span> T, l, time;<br><span class="hljs-type">char</span> fuzadu[<span class="hljs-number">120</span>];<br><span class="hljs-type">int</span> flag1, from, to, sum, flag2, top, res;<br><span class="hljs-type">int</span> used[<span class="hljs-number">150</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> c;<br>cin &gt;&gt; c;                              <span class="hljs-comment">//循环里的第一个字符 入栈还是出栈 </span><br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;F&#x27;</span>) flag1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <br>&#123;<br>flag1 = <span class="hljs-number">0</span>;<br>used[stack[top--].ch] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cin &gt;&gt; c;                             <span class="hljs-comment">//循环里的第二个字符 变量名 </span><br><span class="hljs-keyword">if</span>(flag1)<br>&#123;<br><span class="hljs-keyword">if</span>(used[c]) flag2 = <span class="hljs-number">1</span>;<br>used[c] = <span class="hljs-number">1</span>;<br>stack[++top].ch = c;<br>&#125;<br>cin &gt;&gt; c;                             <span class="hljs-comment">//循环里的第三个字符 起始值 </span><br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;n&#x27;</span>) from = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>from = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;from = from * <span class="hljs-number">10</span>+ c -<span class="hljs-string">&#x27;0&#x27;</span>; c = <span class="hljs-built_in">getchar</span>();&#125;<br>&#125;<br>cin &gt;&gt; c;                             <span class="hljs-comment">//循环里的第四个字符 终结值 </span><br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;n&#x27;</span>) to = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">else</span> <br>&#123;<br>to = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;to = to * <span class="hljs-number">10</span>+ c -<span class="hljs-string">&#x27;0&#x27;</span>; c = <span class="hljs-built_in">getchar</span>();&#125;<br>&#125;<br><span class="hljs-type">int</span> nt = to - from;<br><span class="hljs-keyword">if</span>(nt &gt; <span class="hljs-number">100</span>) stack[top].sj = <span class="hljs-number">1</span>;<span class="hljs-comment">//O(n)的复杂度</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nt &lt; <span class="hljs-number">0</span>) stack[top].sj = -inf;<span class="hljs-comment">//O(gg)的复杂度</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nt &gt;= <span class="hljs-number">0</span> &amp;&amp; nt &lt;= <span class="hljs-number">100</span>) stack[top].sj = <span class="hljs-number">0</span>;<span class="hljs-comment">//O(1)的复杂度</span><br>stack[top].ans = stack[top].sj + stack[top - <span class="hljs-number">1</span>].ans;<br>res = <span class="hljs-built_in">max</span>(res, stack[top].ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;complexity.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;complexity.out&quot;, &quot;w&quot;, stdout);</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-built_in">memset</span>(stack, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(stack));<br><span class="hljs-built_in">memset</span>(used, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(used));<br>top = <span class="hljs-number">0</span>;flag1 = <span class="hljs-number">0</span>, flag2 = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, time = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;l);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, fuzadu);<br><span class="hljs-type">int</span> len1 = <span class="hljs-built_in">strlen</span>(fuzadu);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; len1; ++i)                          <span class="hljs-comment">//处理要求的时间复杂度 </span><br>&#123;<br><span class="hljs-keyword">if</span>(fuzadu[i] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>&#123;<br>time = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(fuzadu[i] == <span class="hljs-string">&#x27;^&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(fuzadu[j] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; fuzadu[j] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;time = time * <span class="hljs-number">10</span> + fuzadu[j] - <span class="hljs-string">&#x27;0&#x27;</span>;j++;&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= l; ++i)<br><span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">if</span>(top != <span class="hljs-number">0</span> || flag2)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERR\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(res == time) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(time != res) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模拟</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小凯的疑惑</title>
    <link href="/2018/10/23/math/"/>
    <url>/2018/10/23/math/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>至此，noip2017圆满ak，也更加感受到自己的成长与变化。在此写下这六道题的题解，以祭奠去年走的太多弯路。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有 无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扩欧是什么？喵喵喵？</p><p>我们设答案为x，两种金币的面值为a,b，设b为较小的那一个。得到一个式子</p><p>$x \equiv ma(mod \quad b)(1&lt;&#x3D;m&lt;&#x3D;b - 1)$</p><p>转化一下</p><p>$x &#x3D; ma + nb(1&lt;&#x3D;m&lt;&#x3D;b - 1)$</p><p>如果n&gt;&#x3D;0的话就表示x可以被a,b组成，那就不符合题意，所以我们让n&#x3D;&#x3D;-1。</p><p>式子变为</p><p>$x &#x3D; ma - b$</p><p>由于要让x最大，所以m取最大值b-1，所以原式变为</p><p>$x &#x3D; (b - 1)  \times  a - b &#x3D; a  \times  b - a -b$</p><p>剩下的你懂的，就是30秒钟是事情了</p>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 P2921 【[USACO08DEC]在农场万圣节Trick or Treat on the Farm】</title>
    <link href="/2018/10/21/infarm/"/>
    <url>/2018/10/21/infarm/</url>
    
    <content type="html"><![CDATA[<p>首先这是一个有向图，求从一个点出发能经过的最大点数，本蒟蒻马上想到了爆搜。</p><p>但爆搜的复杂度是n方的，会T掉，所以考虑记忆化搜索。</p><p>但本题的图是有向有环图，不是有向无环图，不能直接跑搜索，所以考虑tarjan缩点重构图形成一个DAG，就可以愉快地跑记搜啦（想学tarjan的，宣传一下我的<a href="https://www.luogu.org/blog/sincereactor/">tarjan的博客</a>）</p><p>顺便偷偷告诉你这题还有个好基友叫<a href="https://www.luogu.org/problemnew/show/P3387">缩点</a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;cstring&gt;<br>using namespace std;<br>struct ss&#123;<br>int next,to;<br>&#125;;ss data[<span class="hljs-number">200010</span>];<br>int n,p,timeclock,top,cnt,nex[<span class="hljs-number">200010</span>];<br>int head[<span class="hljs-number">200010</span>],dfn[<span class="hljs-number">200010</span>],low[<span class="hljs-number">200100</span>],instack[<span class="hljs-number">200010</span>],stack[<span class="hljs-number">200010</span>],belong[<span class="hljs-number">200010</span>],sum[<span class="hljs-number">200010</span>];<br>int f[<span class="hljs-number">200010</span>];<br>void add(int a,int b)<br>&#123;<br>data[++p].next=head[a];<br>data[p].to=b;<br>head[a]=p;<br>&#125;<br>void tarjan(int a)                        //tarjan的详解可以看我的博客哦 <br>&#123;<br>dfn[a]=low[a]=++timeclock;<br>instack[a]=<span class="hljs-number">1</span>;<br>stack[++top]=a;<br>for(int i=head[a];i;i=data[i].next)<br>&#123;<br>int v=data[i].to;<br>if(!dfn[v])<br>&#123;<br>tarjan(v);<br>low[a]=min(low[a],low[v]);<br>&#125;<br>else<br>if(instack[v])<br>low[a]=min(low[a],dfn[v]);<br>&#125;<br>if(dfn[a]==low[a])<br>&#123;<br>cnt++;<br>while(stack[top+<span class="hljs-number">1</span>]!=a)<br>&#123;<br>belong[stack[top]]=cnt;<br>instack[stack[top--]]=<span class="hljs-number">0</span>;<br>sum[cnt]++;<br>&#125;<br>&#125;<br>&#125;<br>void dfs(int a)                            //f[a]表示第i个点能到达的点数 <br>&#123;<br>if(f[a]) return;                       //如果搜过了，就退出 <br>    f[a]=sum[a];<br>    int maxsum=<span class="hljs-number">0</span>;<br>    for(int i=head[a];i;i=data[i].next)<br>    &#123;<br>        if(!f[data[i].to]) dfs(data[i].to);<br>        maxsum=max(maxsum,f[data[i].to]);<br>    &#125;<br>    f[a]+=maxsum;                          //记忆化 <br>&#125;<br>int main()<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nex[i]);<br>add(i,nex[i]);<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>if(!dfn[i])<br>tarjan(i);<br>memset(data,<span class="hljs-number">0</span>,sizeof(data));<br>memset(head,<span class="hljs-number">0</span>,sizeof(head));<br>p=<span class="hljs-number">0</span>;<br>//printf(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>,cnt);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)           <br>&#123;<br>if(belong[i]!=belong[nex[i]])     //缩点操作，将有向有环图转化为有向无环图，方便我们记搜 <br>add(belong[i],belong[nex[i]]);<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>dfs(belong[i]);<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,f[belong[i]]);<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tarjan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tarjan大法之双联通分量</title>
    <link href="/2018/10/21/tarjans/"/>
    <url>/2018/10/21/tarjans/</url>
    
    <content type="html"><![CDATA[<p>写了强联通算法之后发现还不错，干脆一不做二不休，把双联通分量也写了吧（建议在看本文之前先看<a href="https://www.luogu.org/blog/sincereactor/tarjian-tai-fa-zhi-jiang-xie">Tarjan大法之强连通分量与割点桥</a>）</p><p>先看定义</p><p>双连通分量又分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量。求双连通分量可用Tarjan算法。</p><p>连接几个点（边）双连通分量的点（边）就是割点（桥）</p><p>那么一旦我们发现了割点就发现了一个点双连通分量</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">110</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">10010</span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> u, v, next;  <br>&#125;edge[maxm], tp;  <br><span class="hljs-type">int</span> n, m;   <span class="hljs-comment">//点数，边数   </span><br><span class="hljs-type">int</span> head[maxn], no;  <br><span class="hljs-type">int</span> add_bcc[maxn];<span class="hljs-comment">//去掉该点之后能增加的bcc数目  </span><br><span class="hljs-type">int</span> index; <span class="hljs-comment">//时间戳   </span><br><span class="hljs-type">int</span> yltd;   <span class="hljs-comment">//图的初始连通分量   </span><br><span class="hljs-type">int</span> dfn[maxn], low[maxn];<span class="hljs-comment">//时间戳和能回到的最早时间戳   </span><br><span class="hljs-type">int</span> iscut[maxn];<span class="hljs-comment">//是否为割点   </span><br><span class="hljs-type">int</span> bccno[maxn], bcc_cnt; <span class="hljs-comment">//bccno[i]表示i属于哪个bcc   </span><br>stack&lt;node&gt; S;    <span class="hljs-comment">//存储bcc边   </span><br>vector&lt;<span class="hljs-type">int</span>&gt; bcc[maxn];  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    no = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    edge[no].u = u; edge[no].v = v;  <br>    edge[no].next = head[u]; head[u] = no++;  <br>    edge[no].u = v; edge[no].v = u;  <br>    edge[no].next = head[v]; head[v] = no++;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> u, v;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)  <br>    &#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);  <br>        <span class="hljs-built_in">add</span>(u, v);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> father)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> child = <span class="hljs-number">0</span>;  <br>    dfn[cur] = low[cur] = ++index;  <br>    <span class="hljs-type">int</span> k = head[cur];  <br>    <span class="hljs-keyword">while</span>(k != <span class="hljs-number">-1</span>)  <br>    &#123;  <br>        <span class="hljs-type">int</span> v = edge[k].v;   <br>        <span class="hljs-keyword">if</span>(!dfn[v])  <br>        &#123;  <br>            S.<span class="hljs-built_in">push</span>(edge[k]);  <br>            ++child;  <br>            <span class="hljs-built_in">tarjan</span>(v, cur);  <br>            low[cur] = <span class="hljs-built_in">min</span>(low[cur], low[v]);  <br>            <span class="hljs-keyword">if</span>(low[v] &gt;= dfn[cur])     <br>            <span class="hljs-comment">//把更节点看做普通的节点，对根节点这个条件是一定满足的，  </span><br>            <span class="hljs-comment">//可以实现把回溯到根节点剩下的出栈，其实这就是一个新的双连通分量   </span><br>            &#123;  <br>                iscut[cur] = <span class="hljs-number">1</span>;  <br>                ++add_bcc[cur];  <br>                ++bcc_cnt;<span class="hljs-comment">//准备把新的双连通分量加入bcc   </span><br>                bcc[bcc_cnt].<span class="hljs-built_in">clear</span>();  <br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)  <br>                &#123;  <br>                    tp = S.<span class="hljs-built_in">top</span>(); S.<span class="hljs-built_in">pop</span>();  <br>                    <span class="hljs-keyword">if</span>(bccno[tp.u] != bcc_cnt)  <br>                    &#123;  <br>                        bcc[bcc_cnt].<span class="hljs-built_in">push_back</span>(tp.u);  <br>                        bccno[tp.u] = bcc_cnt;  <br>                    &#125;  <br>                    <span class="hljs-keyword">if</span>(bccno[tp.v] != bcc_cnt)  <br>                    &#123;  <br>                        bcc[bcc_cnt].<span class="hljs-built_in">push_back</span>(tp.v);  <br>                        bccno[tp.v] = bcc_cnt;  <br>                    &#125;  <br>                    <span class="hljs-keyword">if</span>(tp.u == edge[k].u &amp;&amp; tp.v == edge[k].v) <span class="hljs-keyword">break</span>;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dfn[v] &lt; dfn[cur] &amp;&amp; edge[k].v != father)  <br>        &#123;  <br>            <span class="hljs-comment">//dfn[v] &lt; dfn[cur]的判断是为了防止当前cur为割点，然后它刚访问的一个双连通分量里有一个较深的点  </span><br>            <span class="hljs-comment">//访问过了。然后再从cur访问，如果不判断就会将这个点加入S，造成错误，见上图。   </span><br>            <span class="hljs-comment">//可以看到时间戳走到6再次回溯到2时，还能通过2对2-4这条边进行一次尝试，不判断的话4会被加到S  </span><br>            S.<span class="hljs-built_in">push</span>(edge[k]);  <br>            low[cur] = <span class="hljs-built_in">min</span>(low[cur], dfn[v]);  <br>        &#125;  <br>        k = edge[k].next;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(father &lt; <span class="hljs-number">0</span>)  <br>    &#123;  <br>        <span class="hljs-comment">//把根节点看做普通节点了，所以下面最后的特殊判断必需。   </span><br>        <span class="hljs-keyword">if</span>(child &gt; <span class="hljs-number">1</span>) iscut[cur] = <span class="hljs-number">1</span>, add_bcc[cur] = child<span class="hljs-number">-1</span>;  <br>        <span class="hljs-keyword">else</span> iscut[cur] = <span class="hljs-number">0</span>, add_bcc[cur] = <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Find_Cut</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    index = bcc_cnt = yltd = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">memset</span>(add_bcc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> add_bcc);  <br>    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> num);  <br>    <span class="hljs-built_in">memset</span>(iscut, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> iscut);  <br>    <span class="hljs-built_in">memset</span>(bccno, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> bccno);  <br>    <span class="hljs-built_in">memset</span>(low, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> low);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)  <br>    &#123;  <br>        <span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">tarjan</span>(i, <span class="hljs-number">-1</span>), ++yltd;  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutAll</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)  <br>    &#123;  <br>        <span class="hljs-keyword">if</span>(iscut[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d是割点，&quot;</span>, i);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;去掉点%d之后有%d个双连通分量\n&quot;</span>, i, add_bcc[i]+yltd);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutBcc</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有%d个BCC\n&quot;</span>, bcc_cnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= bcc_cnt; ++i)  <br>    &#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BCC%d有%d个点: &quot;</span>, i, bcc[i].<span class="hljs-built_in">size</span>());    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bcc[i].<span class="hljs-built_in">size</span>(); ++j) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, bcc[i][j]);    <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m))  <br>    &#123;  <br>        <span class="hljs-built_in">init</span>();  <br>        <span class="hljs-built_in">input</span>();  <br>        <span class="hljs-built_in">Find_Cut</span>(<span class="hljs-number">1</span>, n);  <br>        <span class="hljs-built_in">PutAll</span>(<span class="hljs-number">1</span>, n);  <br>        <span class="hljs-built_in">PutBcc</span>();  <br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>至于边其实就是找到桥后打上标记然后在遍历一次就行了</p><p>放一个关于圆方树的学习资料<a href="https://download.csdn.net/download/simpsonk/10172077">博客</a></p>]]></content>
    
    
    <categories>
      
      <category>tarjan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CDQ分治</title>
    <link href="/2018/10/21/cdq/"/>
    <url>/2018/10/21/cdq/</url>
    
    <content type="html"><![CDATA[<h3 id="博客背景"><a href="#博客背景" class="headerlink" title="博客背景"></a>博客背景</h3><p>呜呜呜，今天考试考得我元气大伤（交了火锅费又交了水费），搞得只能去食堂了。一怒之下，反手学一个CDQ分治（t2正解）</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>先了解一下题目，看看它是来干什么的</p><blockquote><p>NOIP 要来了，NS 队要选择最好的选手去参加。幸运地，教练可以从 N 个非<br>常棒的选手中选择队员，这些选手被标上 1 到 N(3 ≤ N ≤ 400000)。为了选出的选手是最好<br>的，教练组织了三次竞赛并给出每次竞赛排名。每个选手都参加了每次竞赛并且每次竞赛都<br>没有并列的。当 A 在所有竞赛中名次都比 B 前，我们就说 A 是比 B better。如果没有人比 A<br>better，我们就说 A 是 excellent。求 excellent 选手的个数。</p></blockquote><p>如数据：</p><p>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-number">10</span><br><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span><br><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-number">3</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>(说明 1 2 3 5)”</p><p>可以看出，每个人在每次考试都有一个排名,相当于一个属性，我们定义一个f[i]，表示有f[i]个人的三次排名都大于i，则求有多少i满足f[i]&#x3D;0。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>这是一个三维偏序的问题，让我们一维一维地进行解决</p><h4 id="第一维"><a href="#第一维" class="headerlink" title="第一维"></a>第一维</h4><p>我们考虑进行一个快排使其x有序</p><h4 id="第二维"><a href="#第二维" class="headerlink" title="第二维"></a>第二维</h4><p>我们考虑进行一个CDQ分治</p><p>首先我们假想有一个序列，我们把它一刀切成两段，因为操作一的排序使它左边区间的x一定小于右边区间的x，它的左边和右边的y也是有序的。那我们考虑计算左边区间对右边区间产生的贡献，即左边的y小于右边的y，就会产生一个贡献，我们把它投射到第三维上，一起进行一个统计。</p><h4 id="第三维"><a href="#第三维" class="headerlink" title="第三维"></a>第三维</h4><p>我们考虑进行一个树状数组前缀和</p><p>因为我们满足前两维要求的元素已经投影到了第三维上，我们将z作为下标，那么满足要求的元素数量就是z的前缀和，维护一下即可。</p><p>没了啦</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><del>其实这代码是从<a href="https://www.luogu.org/problemnew/show/P3810">这个题上</a>改过来的</del></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;cstring&gt;</span><br><span class="hljs-comment">#include &lt;algorithm&gt;</span><br>using namespace std;<br>const <span class="hljs-keyword">int</span> N=<span class="hljs-number">100010</span>;<br>struct flower&#123;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>,<span class="hljs-keyword">y</span>,z,ans,num;<br>&#125;;flower a[N],b[N];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> tree[N&lt;&lt;<span class="hljs-number">1</span>],ans[N],data[<span class="hljs-number">5</span>][N];<br><span class="hljs-keyword">int</span> cmp(flower a,flower b)<br>&#123;<br><span class="hljs-keyword">if</span>(a.x!=b.x) <span class="hljs-keyword">return</span> a.x&lt;b.x;<br><span class="hljs-keyword">if</span>(a.y!=b.y) <span class="hljs-keyword">return</span> a.y&lt;b.y;<br><span class="hljs-keyword">if</span>(a.z!=b.z) <span class="hljs-keyword">return</span> a.z&lt;b.z;<br>&#125;<br><span class="hljs-keyword">int</span> same(flower a,flower b)<br>&#123;<br><span class="hljs-keyword">return</span> (a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.z==b.z);<br>&#125;<br><span class="hljs-keyword">int</span> lowbit(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">x</span>&amp;(-<span class="hljs-keyword">x</span>);<br>&#125;<br>void add(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>,<span class="hljs-keyword">int</span> <span class="hljs-keyword">y</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-keyword">x</span>;i&lt;=n;i+=lowbit(i)) tree[i]+=<span class="hljs-keyword">y</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> query(<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>)<br>&#123;<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-keyword">x</span>;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i)) res+=tree[i];<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>void cd<span class="hljs-string">q(int l,int r)</span><br>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>cd<span class="hljs-string">q(l,mid)</span>;cd<span class="hljs-string">q(mid+1,r)</span>;<br><span class="hljs-keyword">int</span> p=l,<span class="hljs-keyword">q</span>=mid+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(p&lt;=mid&amp;&amp;(<span class="hljs-keyword">q</span>&gt;r||a[p].y&lt;=a[<span class="hljs-keyword">q</span>].y)) b[i]=a[p++];<span class="hljs-regexp">//</span>归并的经典操作<br><span class="hljs-keyword">else</span> b[i]=a[<span class="hljs-keyword">q</span>++];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)<br>&#123;<br>a[i]=b[i];<br><span class="hljs-keyword">if</span>(a[i].num&lt;=mid) add(a[i].z,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> a[i].ans+=query(a[i].z);   <span class="hljs-regexp">//</span>将其转移到树状数组上<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)<br><span class="hljs-keyword">if</span>(a[i].num&lt;=mid) add(a[i].z,-<span class="hljs-number">1</span>);<span class="hljs-regexp">//</span>清空树状数组<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br><span class="hljs-regexp">//</span>freopen(<span class="hljs-string">&quot;team.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br><span class="hljs-regexp">//</span>freopen(<span class="hljs-string">&quot;team.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br> &#123;<br> scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>&quot;</span>,&amp;data[i][j]);<br>     &#125;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)//转化为排名<br>     a[data[<span class="hljs-number">1</span>][i]].x=i;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     a[data[<span class="hljs-number">2</span>][i]].y=i;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     a[data[<span class="hljs-number">3</span>][i]].z=i;<br><span class="hljs-keyword">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>a[i].num=i;<br>cd<span class="hljs-string">q(1,n)</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans[a[i].ans]++;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\n&quot;</span>,ans[<span class="hljs-number">0</span>]);<span class="hljs-regexp">//</span>前面没人（无敌是多么寂寞<span class="hljs-variable">%%</span>）<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>玄学算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰数</title>
    <link href="/2018/10/21/Catalan/"/>
    <url>/2018/10/21/Catalan/</url>
    
    <content type="html"><![CDATA[<h3 id="博客背景"><a href="#博客背景" class="headerlink" title="博客背景"></a>博客背景</h3><p>好像没有什么背景，单纯想学一下，(其实是今颠没有考试，高高兴兴），直接进入正题吧</p><h3 id="数列长相"><a href="#数列长相" class="headerlink" title="数列长相"></a>数列长相</h3><p>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …</p><p>打表发现有这个规律就上吧</p><h3 id="递推式（规律）"><a href="#递推式（规律）" class="headerlink" title="递推式（规律）"></a>递推式（规律）</h3><p><img src="https://s1.ax1x.com/2018/10/21/iB435t.png" alt="iB435t.png"></p><p>还有另类的</p><p>$f(n)&#x3D;f(n-1) \times (4 \times n-2)&#x2F;(n+1);$</p><p>解为</p><p>$f(n)&#x3D;C(2n,n)&#x2F;(n+1) (n&#x3D;0,1,2,…)$</p><p>另类解为</p><p>$f(n)&#x3D;c(2n,n)-c(2n,n-1)(n&#x3D;0,1,2,…)$</p><h3 id="递推式的应用"><a href="#递推式的应用" class="headerlink" title="递推式的应用"></a>递推式的应用</h3><h4 id="括号化问题"><a href="#括号化问题" class="headerlink" title="括号化问题"></a>括号化问题</h4><p>矩阵连乘： $P&#x3D;a1×a2×a3×……×an$，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？（$f(n)$种）</p><h4 id="进出栈问题"><a href="#进出栈问题" class="headerlink" title="进出栈问题"></a>进出栈问题</h4><p>我们设$h(n)$为长度为n的序列出栈方式，设$k$为最后一个出栈的元素，那么比他先入栈的元素出栈，方式为$h(k-1)$种,比它后入栈的元素出栈，方式为$h(n-k)$种，由于这两种情况互相独立，满足乘法原理，于是当$k$为最后一个元素出栈时总出栈方案为$h(k-1) \times h(n-k)$种，各个k的情况为并列关系，满足加法原理，所以为典型的卡特兰递推式。</p><p>类似问题 买票找零<br>有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈)</p><h4 id="凸多边形三角划分"><a href="#凸多边形三角划分" class="headerlink" title="凸多边形三角划分"></a>凸多边形三角划分</h4><p>因为凸多边形的任意一条边必定属于某一个三角形，所以我们以某一条边为基准，以这条边的两个顶点为起点P1和终点Pn（P即Point），将该凸多边形的顶点依序标记为P1、P2、……、Pn，再在该凸多边形中找任意一个不属于这两个点的顶点Pk（2&lt;&#x3D;k&lt;&#x3D;n-1），来构成一个三角形，用这个三角形把一个凸多边形划分成两个凸多边形，其中一个凸多边形，是由P1，P2，……，Pk构成的凸k边形（顶点数即是边数），另一个凸多边形，是由Pk，Pk+1，……，Pn构成的凸n-k+1边形</p><h4 id="给定节点组成二叉树的问题。"><a href="#给定节点组成二叉树的问题。" class="headerlink" title="给定节点组成二叉树的问题。"></a>给定节点组成二叉树的问题。</h4><p>　　给定N个节点，能构成多少种形状不同的二叉树？ </p><p>　　先去一个点作为顶点,然后左边依次可以取0至N-1个相对应的,右边是N-1到0个,两两配对相乘,就是$h(0) \times h(n-1) + h(2) \times h(n-2) +…+ h(n-1)h(0)&#x3D;h(n)$（能构成h(N)个）</p>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NOIP知识范围</title>
    <link href="/2018/10/21/noip/"/>
    <url>/2018/10/21/noip/</url>
    
    <content type="html"><![CDATA[<h2 id="加-号是选学，加粗为重点，重要值排序不分先后"><a href="#加-号是选学，加粗为重点，重要值排序不分先后" class="headerlink" title="加*号是选学，加粗为重点，重要值排序不分先后"></a>加*号是选学，加粗为重点，重要值排序不分先后</h2><h4 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h4><p>贪心、枚举、分治、二分、倍增、*构造、高精、模拟</p><h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>最短路（dijkstra、spfa、floyd），差分约束</p><p>最小生成树（kruskal、prim）</p><p>并查集（扩展域）</p><p>拓扑排序</p><p>二分图染色，*二分图匹配</p><p>tarjan找scc、桥、割点，缩点</p><p>*分数规划</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树上倍增（LCA）</p><p>树的直径、树的重心</p><p>dfs序</p><p>*树链剖分</p><h4 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h4><p>gcd、lcm</p><p>埃氏筛法</p><p>欧拉筛法</p><p>exgcd，求解同余方程、逆元</p><p>快速幂</p><p>*组合数学</p><p>矩阵</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>链表、队列（单调队列）、栈（单调栈）</p><p>堆、st表、hash表</p><p>线段树、树状数组</p><p><strong>分块大法</strong>（暴力出奇迹）</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>背包DP、<strong>树形DP</strong>、记忆化搜索、递推</p><p>区间DP、序列DP</p><p>*DP优化（不涉及斜率优化、四边形不等式等等）</p><p><strong>状态压缩</strong></p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>暴搜（dfs、bfs）</p><p>搜索的剪枝</p><p>双向bfs</p><p>启发式搜索（A*）</p><p>迭代加深搜索、* IDA*</p><p>*随机化搜索</p><h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>STL的基本使用方法</p><p>脑洞的正确使用方法</p><h4 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h4><p><a href="https://blog.csdn.net/mashirosky/article/details/52503032">附代码</a></p><p><a href="https://blog.csdn.net/C20180630/article/details/53158021">注意事项</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>扩展欧几里得（青蛙的约会）</title>
    <link href="/2018/10/21/exgcd/"/>
    <url>/2018/10/21/exgcd/</url>
    
    <content type="html"><![CDATA[<p>此题其实就是扩展欧几里德算法－求解不定方程，线性同余方程。</p><p>分析一：得出方程，建立模型</p><p>设过s步后两青蛙相遇，则必满足以下等式:</p><p>$(x+m \times s)-(y+n \times s)&#x3D;k \times l(k&#x3D;0,1,2….)$</p><p>稍微变一下形得：</p><p>$(n-m) \times s+k \times l&#x3D;x-y$</p><p>令n -m&#x3D;a,l&#x3D;b,x-y&#x3D;c,即</p><p>$a \times s+b \times k&#x3D;c$  &#x2F;&#x2F;得出这个方程是关键</p><p>此处 a，b，c 为常数，s，k为未知数。</p><p>只要上式存在整数解，则两青蛙能相遇，否则不能。</p><p>首先想到的一个方法是用两次for循环来枚举s,k的值，看是否存在s,k的整数解，若存在则输出最小的s，但显然这种方法是不可取的，谁也不知道最小的s是多大，如果最小的s很大的话，超时是明显的。</p><p>学习：如何解这个方程？用欧几里得扩展原理</p><p>先来看看欧几里得算法：</p><p>欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数</p><p>定理：gcd(a,b) &#x3D; gcd(b,a mod b)   &#x2F;&#x2F; gcd代表最大公约数</p><p>证明如下：</p><p>a可以表示成a &#x3D; kb + r，则r &#x3D; a mod b</p><p>假设d是a,b的一个公约数，则有</p><p>d|a, d|b，而r &#x3D; a - kb，因此d|r</p><p>因此d是(b,a  mod b)的公约数</p><p>假设d 是(b,a mod b)的公约数，则</p><p>d | b , d |r ，但是a &#x3D; kb +r</p><p>因此d也是(a,b)的公约数</p><p>因此(a,b)和(b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证</p><p>欧几里德算法就是根据这个原理来做的，其算法用C语言描述为:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Gcd</span><span class="hljs-params">(b, a % b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然你也可以写成迭代形式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> r = b;<br>        b = a % b;<br>        a = r;<br>    &#125;<br>     <span class="hljs-keyword">return</span> a;<br>&#125; <br></code></pre></td></tr></table></figure><p>补充: 扩展欧几里德算法是用来求解a \times x+b \times y&#x3D;Gcd(a,b)的解(根据数论中的相关定理解一定存在)。  证明如下</p><p>$ax+by$</p><p>$&#x3D;gcd(a,b)$          </p><p>$&#x3D;gcd(b,$a%b)$</p><p>$&#x3D;bx’+(a % b)y’ $ </p><p>$&#x3D;bx’+ ( a- (a&#x2F;b)  \times b)y’$</p><p>$&#x3D;bx’+ ay’- (a&#x2F;b)  \times b  \times y’$</p><p>$&#x3D;ay’+ b(x’- (a&#x2F;b) y’)$</p><p>所以$ax+by&#x3D;ay’+ b(x’- (a&#x2F;b) y’)$</p><p>所以$x&#x3D;y’$，$y&#x3D;x’-(a&#x2F;b) y’$</p><p>下面是一个使用C++的实现：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gml">int exGcd(int a, int b, int &amp;<span class="hljs-variable language_">x</span>, int &amp;<span class="hljs-variable language_">y</span>)<br> <br>　　&#123;<br>    　　<span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    　　&#123;<br>        　　<span class="hljs-variable language_">x</span> = <span class="hljs-number">1</span>;<br>        　　<span class="hljs-variable language_">y</span> = <span class="hljs-number">0</span>;<br>       　　 <span class="hljs-keyword">return</span> a;<br>    　　&#125;<br>    　　int r = exGcd(b, a % b, <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>);<br>    　　int t = <span class="hljs-variable language_">x</span>;<br>    　　<span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">y</span>;<br>    　　<span class="hljs-variable language_">y</span> = t - a / b  *  <span class="hljs-variable language_">y</span>;<br>　　    <span class="hljs-keyword">return</span> r;<br>　　&#125;<br></code></pre></td></tr></table></figure><p>利用扩展欧几里得算法求解不定方程$a  \times  x + b  \times  y &#x3D; n$的整数解的求解全过程，步骤如下：</p><p>　　1、先计算Gcd(a,b)，若n不能被Gcd(a,b)整除，则方程无整数解；否则，在方程两边同时除以Gcd(a,b)，得到新的不定方程$a’  \times  x + b’  \times  y &#x3D; n’$，此时Gcd(a’,b’)&#x3D;1;</p><p>   2、利用扩展欧几里德算法求出方程$a’  \times  x + b’  \times  y &#x3D; 1$的一组整数解x0,y0，则$n’  \times  x0,n’  \times  y0$是方程$a’  \times  x + b’  \times  y &#x3D; n’$的一组整数解；</p><p>　　3、根据数论中的相关定理，可得方程a’  \times  x + b’  \times  y &#x3D; n’的所有整数解为：</p><p>  $x &#x3D; n’  \times  x_0 + b’  \times  t$</p><p>  $y &#x3D; n’  \times  y_0 - a’  \times  t$       (t&#x3D;0,1,2，……)</p><p>　上面的解也就是$a  \times  x + b  \times  y &#x3D; n$ 的全部整数解</p>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 P2743 【[USACO5.1]乐曲主题Musical Themes】</title>
    <link href="/2018/10/21/music/"/>
    <url>/2018/10/21/music/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希大法吼！"><a href="#哈希大法吼！" class="headerlink" title="哈希大法吼！"></a>哈希大法吼！</h2><p>这道题不需要用后缀数组这些<del>花里胡哨</del>的，用纯noip内容的hash+二分是可以<del>水</del>过的。</p><p>首先我们发现我们需要寻找最长的一种没有公共部分的重复出现的子串，使这个串中数字之间的差不变。那我们将这n个数前后做差，得到另一个长度是n-1的序列。问题转化为求出这个序列的最长重复子串，且这些子串不能重叠。</p><p>我们发现这种串的长度满足单调性，所以考虑二分串的长度，至于如何判断重复的子串，就用hash处理整个串，使我们的hash满足前缀和的性质，到时候相减进行判断就行了。</p><p>让我们看看如何<del>乱搞</del>构造一个好的hash</p><p>1.首先，你需要一个unsigned long long来防止hash值策马奔腾而爆掉</p><p>2.然后，开始乱搞，越乱越好，把想要卡你hash的数据秀晕</p><p>3.之后取个模，装入链表或vector以便于查找</p><p>我的hash是这样的：</p><p>假设有一串数1,2,3,4,5</p><p>先随便设一个几千的值x（比如你的生日？）</p><table><thead><tr><th align="left">hash(1)</th><th align="left">hash(2)</th><th align="left">hash(3)</th><th align="left">hash(4)</th><th align="left">hash(5)</th></tr></thead><tbody><tr><td align="left">hash(2)+1</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left">hash(3)*x+2</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left">hash(2)*x+3</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">hash(4)*x+4</td><td align="left"></td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">5</td></tr></tbody></table><p>其实也就是这个</p><p>$hash(5)&#x3D;5*x^0$</p><p>$hash(4)&#x3D;5<em>x^1+4</em>x^0$</p><p>$hash(3)&#x3D;5<em>x^2+4</em>x^1+3*x^0;$</p><p>$hash(2)&#x3D;5<em>x^3+4</em>x^2+3<em>x^1+2</em>x^0$</p><p>$hash(1)&#x3D;5<em>x^4+4</em>x^3+3<em>x^2+2</em>x^1+1*x^0;$</p><p>总通式:$H(i)&#x3D;s[n]x^{n-i}+s[n-1]x^{x-i-1}+……+s[i+1]x+s[i]$</p><p>因为$hash$值只与$s[i]~s[i+L-1]$和$L$有关，所以就可以为所欲为了</p><p>最后送一句话</p><blockquote><p>Hash的精髓在于乱搞——叶某富</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;cstring&gt;</span><br><span class="hljs-comment">#include &lt;vector&gt;</span><br>using namespace std;<br>typedef unsigned long long ull;<br>const int <span class="hljs-attribute">N</span>=200010;<br>const int <span class="hljs-attribute">mod</span>=2007;<br>const ull <span class="hljs-attribute">Rand</span>=5201;<br>struct ss&#123;<br>    ull zhi;int pos;<br>    ss(ull a,int b)<br>    &#123;<br>        <span class="hljs-attribute">zhi</span>=a;pos=b;<br>    &#125;<br>&#125;;<br>vector&lt;ss&gt; G[mod];<br>int n,tlen,ans;<br>ull Hash[N],base[N];<br>int data[N],tmp[N];<br>void Init()<br>&#123;<br>    base[0]=1;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;n;i++)<br>    tmp[i]=data[i+1]-data[i];<br>    <span class="hljs-attribute">tlen</span>=n-1;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;n;i++)<br>    &#123;<br>        Hash[i]=Hash[i-1]*Rand+tmp[i];<br>        base[i]=base[i-1]*Rand;<br>    &#125;<br>&#125;<br>int query(ull v,int wei,int l)<br>&#123;<br>    int <span class="hljs-attribute">x</span>=v%mod;<br>    G[x].push_back(ss(v,wei));<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;G[x].size();i++)<br>    <span class="hljs-keyword">if</span>(G[x][i].<span class="hljs-attribute">zhi</span>==v&amp;&amp;wei-G[x][i].pos&gt;=l+1)<br>    return 1;<br>    return 0;<br>&#125;<br>int check(int l)<br>&#123;<br>    l--;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;mod;i++)<br>    G[i].clear();<br>    int <span class="hljs-attribute">flag</span>=0;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=tlen-l+1;i++)<br>    &#123;<br>        ull <span class="hljs-attribute">v</span>=Hash[i+l-1]-Hash[i-1]<span class="hljs-number">*ba</span>se[l];<br>        <span class="hljs-keyword">if</span>(query(v,i,l))<br>        &#123;<br>            <span class="hljs-attribute">flag</span>=1;return 1;<br>        &#125;<br>    &#125;<br>    return 0;<br>&#125;<br>int main()<br>&#123;<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;i++)<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data[i]);<br>    Init();<br>    int <span class="hljs-attribute">l</span>=5,r=n;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        int mid=(l+r)/2;<br>        <span class="hljs-keyword">if</span>(check(mid))<br>        &#123;<br>            <span class="hljs-attribute">ans</span>=mid;<br>            <span class="hljs-attribute">l</span>=mid+1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-attribute">r</span>=mid;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分图相关总结</title>
    <link href="/2018/10/21/lyfzs/"/>
    <url>/2018/10/21/lyfzs/</url>
    
    <content type="html"><![CDATA[<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>先说说</p><h4 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h4><p>我们通过搜索每个男孩纸喜欢的女孩，如果这个女孩没有男友，就进行配对，如果已经名花有主，那就看看她的男友能不能换人（天下从不缺渣男……），所以我们dfs的作用是看这个男孩能不能找一个没有被追求过的女孩进行追求（天下从不缺怂男…..），所以匈牙利的经典操作中的一段代码</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">match</span>[girl]==<span class="hljs-number">-1</span>|<span class="hljs-type">|dfs</span>(<span class="hljs-keyword">match</span>[girl]))<br></code></pre></td></tr></table></figure><p>就可以理解了，表示这个男孩A追求的女孩还没有人追求或者正在追求这个女孩的男孩B可以另求新欢，那么他就可以追求这个女孩</p><p>再说说</p><h4 id="带权二分图匹配。"><a href="#带权二分图匹配。" class="headerlink" title="带权二分图匹配。"></a>带权二分图匹配。</h4><p>由于上面这个模型引起了众多女同胞的愤怒，所以我们换一个</p><p>我们现在有N个男生和N个女生，女生对一些男生有一定的好感度，要如何匹配使得女生们对她们的男友的好感度之和最大？</p><p>我们在匈牙利的基础上加一个点权，表示女生对男生和男生对女生的期望值，女生点权置为女生对所有男生的最大好感度，如果女生对男生的期望值加上男生对女生的期望值之和等于边权，表示女生可以选择这位男生（当然其余备胎也是有机会的），如果这个女生发现自己所有喜欢的男生都被抢走了，就会<del>横刀夺爱</del>（女人何必为难女人）来使答案最优。</p><p>比如十班要换座位了，现在给你一些人让你配对，让她们的好感度最大（快乐地生活在一起….），你一定求出最优解，否则Bug哥会把你打成篮球（逃）</p><p>以下纯属娱乐，切勿对号入座！（Bug不要捶我！）</p><p><img src="https://s1.ax1x.com/2018/10/21/iBgegJ.png" alt="iBgegJ.png"></p><p>一开始江美翔同学的expect（后用ex）为2，于是与Bug哥2+0&#x3D;&#x3D;2，配对成功！</p><p>然后渣渣欣来了，她表示Bug哥是我的，于是江美翔尝试换人，但江美翔不干，凭什么啊（主要是找不到人符合配对原则），于是尝试失败</p><p>所以尝试修改，这次我们遍历到了江美翔，渣渣欣和Bug哥，所以对他们的期望值进行修改（不然打起来怎么办），渣渣欣ex–，江美翔ex–，Bug发现竟然有两个人喜欢他，于是Bug哥ex++；</p><p><img src="https://s1.ax1x.com/2018/10/21/iBgmv9.png" alt="iBgmv9.png"></p><p>她们进行协商后，江美翔发现文振鑫好像海星，于是江美翔选择了文振鑫，渣渣欣成功得手Bug哥。</p><p>由于凤姐对熊大爱得太深，所以没有人敢来抢人，于是牵手成功。</p><p>感谢你为我调换座位排忧解难，谢谢你的参与！恭喜你获得讲台前第一方位置附赠姚宝贝儿按摩票一张！</p><p>撒花！</p><p>所以我们可以看出，我们通过修改男孩与女孩的期望值来使调整答案，使其满足最小损失的条件下跑出匈牙利算法。复杂度为$n^3$。（由于博主太懒讲的十分简略，相关原理不懂的可以来私下解决….）</p><p>LYH大佬出的<a href="https://www.luogu.org/problemnew/show/T41356">模板题</a>，数据有些毒瘤</p><p>说一下，KM算法针对的是一个完备的最佳匹配，而最大权匹配不一定是完备的，所以我们要对之前所有没有连上的边加上，边权赋为0就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> INF=<span class="hljs-number">1e15</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,e,change;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> love[N][N],ex_boy[N],ex_girl[N],slack[N];<br><span class="hljs-type">int</span> vis_boy[N],vis_girl[N],match[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> girl)</span>     <span class="hljs-comment">//这其实是个匈牙利 </span></span><br><span class="hljs-function"></span>&#123;<br>vis_girl[girl]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> boy=<span class="hljs-number">1</span>;boy&lt;=m;boy++)<br>&#123;<br><span class="hljs-keyword">if</span>(love[girl][boy]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(vis_boy[boy]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> gap=ex_girl[girl]+ex_boy[boy]-love[girl][boy];<br><span class="hljs-keyword">if</span>(gap==<span class="hljs-number">0</span>)<br>&#123;<br>vis_boy[boy]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(match[boy]==<span class="hljs-number">-1</span>||<span class="hljs-built_in">dfs</span>(match[boy]))<br>&#123;<br>match[boy]=girl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>slack[boy]=<span class="hljs-built_in">min</span>(slack[boy],gap);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(match,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(match));<br><span class="hljs-built_in">memset</span>(ex_boy,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ex_boy));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>ex_girl[i]=love[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>ex_girl[i]=<span class="hljs-built_in">max</span>(ex_girl[i],love[i][j]);              <span class="hljs-comment">//赋为最大期望 </span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br><span class="hljs-built_in">memset</span>(slack,<span class="hljs-number">63</span>,<span class="hljs-built_in">sizeof</span>(slack));<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">memset</span>(vis_boy,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis_boy));<br><span class="hljs-built_in">memset</span>(vis_girl,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis_girl));<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(k)) <span class="hljs-keyword">break</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> d=INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-keyword">if</span>(!vis_boy[i])d=<span class="hljs-built_in">min</span>(d,slack[i]);  <span class="hljs-comment">//修改期望 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(vis_girl[i])ex_girl[i]-=d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-keyword">if</span>(vis_boy[i])ex_boy[i]+=d;<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">if</span>(match[i]!=<span class="hljs-number">-1</span>&amp;&amp;love[match[i]][i]&gt;=<span class="hljs-number">0</span>)res+=love[match[i]][i];   <span class="hljs-comment">//毒瘤三 </span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(love,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(love));<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;e);<br><span class="hljs-keyword">if</span>(n&gt;m) &#123;                               <span class="hljs-comment">//毒瘤一 </span><br>    <span class="hljs-built_in">swap</span>(n,m);<br>    change=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);<br><span class="hljs-keyword">if</span>(change) <span class="hljs-built_in">swap</span>(u,v);<br>love[u][v]=<span class="hljs-built_in">max</span>(love[u][v],w);       <span class="hljs-comment">//毒瘤二 </span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">KM</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>  <span class="hljs-keyword">if</span>(love[i][j]==<span class="hljs-number">-1</span>)<br>   love[i][j]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">KM</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>建模问题刷了大量题后会保持更新（现在太弱了）</p><p>放一些题</p><p><a href="https://www.luogu.org/problemnew/show/P2756">飞行员配对方案</a></p><p><a href="https://www.luogu.org/problemnew/show/P3386">【模板】二分图匹配</a></p><p><a href="https://www.luogu.org/problemnew/show/P1129">矩阵游戏</a></p><p><a href="https://www.luogu.org/problemnew/show/P2055">假期的宿舍</a></p><p><a href="https://www.luogu.org/problemnew/show/UVA11383">少林决胜</a></p><p>相关建模感悟实时更新，今天就这样吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UVA11825 Hackers&#39; Crackdown</title>
    <link href="/2018/10/21/hacker/"/>
    <url>/2018/10/21/hacker/</url>
    
    <content type="html"><![CDATA[<h2 id="UVA11825-Hackers’-Crackdown"><a href="#UVA11825-Hackers’-Crackdown" class="headerlink" title="UVA11825 Hackers’ Crackdown"></a>UVA11825 Hackers’ Crackdown</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假如你是一个黑客，侵入了一个有着n台计算机（编号为1.2.3….n）的网络。一共有n种服务，每台计算机都运行着所有服务。对于每台计算机，你都可以选择一项服务，终止这台计算机和所有与它相邻计算机的该项服务（如果其中一些服务已经停止，那他们继续保持停止状态）。你的目标是让尽量多的服务完全瘫痪(即：没有任何计算及运行着该服务) 输入格式</p><p>输入包含多组数据，每组数据的第一行为整数n(1&lt;&#x3D;n&lt;&#x3D;16):以下n行每行描述一台计算机相邻的计算机，其中第一个数m为相邻计算机个数，接下来的m个整数为这些计算机的编号。输入结束标志n&#x3D;0. 输出格式</p><p>对于每组数据，输出完全瘫痪的服务的数量</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：每个电脑都能影响一部分电脑服务，要求尽量多的服务被完全关闭</p><p>我们想到一个电脑能影响一部分电脑，那我们就能找出一个集合，操作这个集合就能影响所有电脑，然后对所有集合做一个背包即可。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,close,a;<br><span class="hljs-type">int</span> comp[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>],spread[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>],dp[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">17</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(comp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(comp));<br>        <span class="hljs-built_in">memset</span>(spread,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(spread));<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;close);<br>        comp[i]=(<span class="hljs-number">1</span>&lt;&lt;i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;close;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>            comp[i]|=(<span class="hljs-number">1</span>&lt;&lt;a);<span class="hljs-comment">//每个点影响的范围</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>     &#123;<br>     <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>     spread[i]|=comp[j];<span class="hljs-comment">//i这个集合能影响的范围</span><br>     &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=i;s;s=(s<span class="hljs-number">-1</span>)&amp;i)<br>     &#123;<br>     <span class="hljs-keyword">if</span>(spread[s]==(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>)<br>     dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i^s]<span class="hljs-number">+1</span>);<span class="hljs-comment">//背包</span><br>     &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d\n&quot;</span>,++cnt,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>]);<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>状态压缩</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主席树</title>
    <link href="/2018/10/21/zxs/"/>
    <url>/2018/10/21/zxs/</url>
    
    <content type="html"><![CDATA[<p>推荐一个线段树<a href="https://blog.csdn.net/zearot/article/details/48299459">博客</a></p><h3 id="博客背景"><a href="#博客背景" class="headerlink" title="博客背景"></a>博客背景</h3><p>今天虽然听kiana讲了一下午的LCT开了一下午的飞机，但总算还是有点收获，比如它——主席树。</p><h3 id="干什么"><a href="#干什么" class="headerlink" title="干什么"></a>干什么</h3><p>可以看看这个经典的<a href="https://www.luogu.org/problemnew/show/P3834">模板题</a>，维护区间第k小。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>我们想如果没有区间查询这个烦人的条件而是整个序列，我们该怎么办？</p><h4 id="快排呗！"><a href="#快排呗！" class="headerlink" title="快排呗！"></a>快排呗！</h4><p>然而我们闲得蛋疼，要用线段树来做。</p><p>我们先把它排个序离散化一下（……编不下去了），然后建一个线段树，每个节点维护一段区间，表示在节点维护的区间里，大于mid和小于mid的元素的个数sum，就比如我们有个序列1，2，3，4，我们建出来的线段树就是这样的</p><p><img src="https://s1.ax1x.com/2018/10/21/iBY1tx.png" alt="iBY1tx.png"></p><p>如果我们要查询第k小就让它与mid比较，小于就意味着他在左边区间是第k名所以往左，大于就减去mid再往右就行了。</p><p>好像很简单？</p><p>复杂度分析：…..STL大法好！sort大法好！</p><p>这个做法真的闲得蛋疼吗？</p><p>如果是其中的一段区间查询，sort还有用吗？</p><p>没用了。</p><p>但线段树可以吗？</p><p>可以！</p><p>我们考虑一个前缀和的性质，就是说如果在1到L-1的区间中小于k的数有A个，在1到R的区间中小于k的数有B个，那么显然L到R的区间中小于k的数就有B-A个。</p><p>很显然吧！</p><p>于是我们就有一个大胆的想法：我们可以建n棵线段树！第i棵线段树的根维护的是前i个元素的信息，当我们查询L到R的区间时，我们可以将第R棵线段树的sum值减去第L-1棵线段树的sum值就得到了这段区间的sum值啦！</p><p>画个图（空树我们就不管了吧~）</p><p>第一棵</p><p><img src="https://s1.ax1x.com/2018/10/21/iBYM7R.png" alt="iBYM7R.png"></p><p>第二棵</p><p><img src="https://s1.ax1x.com/2018/10/21/iBYlA1.png" alt="iBYlA1.png"></p><p>第三棵</p><p><img src="https://s1.ax1x.com/2018/10/21/iBYG9K.png" alt="iBYG9K.png"></p><p>第四棵就是最开始那棵啦！</p><p>好像还是很简单？</p><p>然而我们遗憾地发现，会爆空间。</p><p>怎么办？</p><p>我们又惊喜的发现，新加的线段树跟上一棵的线段树相比，只有一条路径不同。如果左子树新加节点就继承右子树，反之亦然。这意味着什么?意味着我们可以用之前的线段树的一些节点，比如下图</p><p><img src="https://s1.ax1x.com/2018/10/21/iBY3h6.png" alt="iBY3h6.png"></p><p>因为我们已经对每一棵线段树都十分了解，所以这个丑丑的图应该….不难看懂，说白了就是本棵线段树与上棵线段树相同的我们就不再新建节点，而是连向已有节点来节省空间。</p><p>所以接下来的事情就十分简单啦</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">250010</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br><span class="hljs-type">int</span> l,r,sum;<br>&#125;;ss tree[<span class="hljs-number">20</span>*N];<br><span class="hljs-type">int</span> n,q,node;<br><span class="hljs-type">int</span> size[<span class="hljs-number">20</span>*N],a[N],b[N],root[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>      <span class="hljs-comment">//建树 </span></span><br><span class="hljs-function"></span>&#123;<br>    rt=++node;<br>tree[rt].sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(tree[rt].l,l,mid);<br><span class="hljs-built_in">build</span>(tree[rt].r,mid<span class="hljs-number">+1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pre,<span class="hljs-type">int</span> &amp;rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> pos)</span>    <span class="hljs-comment">//新加一个节点 </span></span><br><span class="hljs-function"></span>&#123;<br>rt=++node;<br><span class="hljs-comment">//printf(&quot;%d\n&quot;,rt);</span><br>tree[rt].l=tree[pre].l;<br>tree[rt].r=tree[pre].r;<br>size[rt]=size[pre]<span class="hljs-number">+1</span>;<span class="hljs-comment">//包含的元素比上一个多一 </span><br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(pos&lt;=mid) <span class="hljs-built_in">add</span>(tree[pre].l,tree[rt].l,l,mid,pos);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(tree[pre].r,tree[rt].r,mid<span class="hljs-number">+1</span>,r,pos);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> pre,<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> l;<br><span class="hljs-type">int</span> cnt=size[tree[rt].l]-size[tree[pre].l];   <span class="hljs-comment">//做差表示这段区间包含的元素 </span><br><span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(cnt&gt;=pos) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(tree[pre].l,tree[rt].l,l,mid,pos);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(tree[pre].r,tree[rt].r,mid<span class="hljs-number">+1</span>,r,pos-cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>   b[i]=a[i];<br>    &#125;<br><span class="hljs-built_in">sort</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+n);<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">unique</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+n)-b<span class="hljs-number">-1</span>;<br><span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,len);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>a[i]=<span class="hljs-built_in">lower_bound</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+len,a[i])-b;<span class="hljs-comment">//离散化 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-built_in">add</span>(root[i<span class="hljs-number">-1</span>],root[i],<span class="hljs-number">1</span>,len,a[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<br>&#123;<br><span class="hljs-type">int</span> l,r,k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);<br><span class="hljs-type">int</span> ans=<span class="hljs-built_in">find</span>(root[l<span class="hljs-number">-1</span>],root[r],<span class="hljs-number">1</span>,len,k);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b[ans]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组的基础应用</title>
    <link href="/2018/10/21/szsz/"/>
    <url>/2018/10/21/szsz/</url>
    
    <content type="html"><![CDATA[<p>本来是想刷一下主席树的，没想到主席树的题用主席树一个都没过（可能我太弱了），一怒之下，向生活屈服，改写树状数组（手动滑稽）。</p><p>看一个题 <a href="https://www.luogu.org/problemnew/show/P1972">HH的项链</a></p><p>题意：询问一段区间出现了多少种元素。</p><p>一开始想的是主席树维护在每一段前缀每种元素出现的次数，询问时相减即可。然后光荣T掉了</p><p>好吧，让我们考虑树状数组。</p><p>我们想，在许多右边界相同的区间内，对答案有贡献的可以只需考虑最右边第一个出现的元素，其余都可以不看他，比如：</p><p>1 2 3 4 5 1</p><p>那么左边的1并没有什么存在的意义</p><p>所以我们考虑用一个树状数组来维护</p><p>怎么搞呢？</p><p>当我们从左往右扫描时，扫到一个点就在他那里+1，然后把它上一次出现的位置-1把它抛弃掉不让他计入答案即可，比如：</p><p>1 2 3 1 4</p><p>在第一个1那里+1，在2,3那里继续加一，然后我们发现又碰到了一个一，怎么办？在第二个1那里++，在上一个1那里–，于是查询（1,4）这个区间时计算前缀和&#x3D;&#x3D;3。</p><p>完结撒花！</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;cstdio&gt;</span><br><span class="hljs-comment">#include &lt;cstring&gt;</span><br><span class="hljs-comment">#include &lt;algorithm&gt;</span><br>using namespace std;<br><span class="hljs-comment">#define lc(x) t[x].l</span><br><span class="hljs-comment">#define rc(x) t[x].r</span><br>const <span class="hljs-keyword">int</span> N=2e6+<span class="hljs-number">5</span>;<br>inline <span class="hljs-keyword">int</span> <span class="hljs-keyword">read</span>()&#123;<br>    char c=getchar();<span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=-<span class="hljs-number">1</span>;c=getchar();&#125;<br>    <span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">x</span>=<span class="hljs-keyword">x</span>*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;c=getchar();&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">x</span>*f;<br>&#125;<br><span class="hljs-keyword">int</span> n, Q, a[N], <span class="hljs-keyword">last</span>[N], <span class="hljs-keyword">pos</span>[N], l, r;<br><span class="hljs-keyword">int</span> c[N];<br>inline void add(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> v) <br>&#123;     <br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-number">0</span>) <br><span class="hljs-keyword">for</span>(;p&lt;=n;p+=(p&amp;-p)) <br>c[p]+=v;<br>&#125;<br>inline <span class="hljs-keyword">int</span> sum(<span class="hljs-keyword">int</span> p)<br>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(;p;p-=(p&amp;-p)) <br>ans+=c[p]; <br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>struct meow<br>&#123;<br>    <span class="hljs-keyword">int</span> l, r, qid;<br>    bool operator &lt;(const meow &amp;a) const <br>&#123;<span class="hljs-keyword">return</span> r&lt;a.r;&#125;<br>&#125;<span class="hljs-string">q[N]</span>;<br><span class="hljs-keyword">int</span> ans[N], now;<br><span class="hljs-keyword">int</span> main() <br>&#123;<br>    n=<span class="hljs-keyword">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br>a[i]=<span class="hljs-keyword">read</span>();<br> Q=<span class="hljs-keyword">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=Q; i++) <br>l=<span class="hljs-keyword">read</span>(), r=<span class="hljs-keyword">read</span>(), <span class="hljs-string">q[i]</span>=(meow)&#123;l, r, i&#125;;<br>    <span class="hljs-keyword">sort</span>(<span class="hljs-keyword">q</span>+<span class="hljs-number">1</span>, <span class="hljs-keyword">q</span>+<span class="hljs-number">1</span>+Q);<br>    now = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) <br>&#123; <br>        <span class="hljs-keyword">last</span>[i] = <span class="hljs-keyword">pos</span>[a[i]]; <span class="hljs-keyword">pos</span>[a[i]] = i;<br>        add(i, <span class="hljs-number">1</span>); <br>add(<span class="hljs-keyword">last</span>[i], -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-string">q[now]</span>.r == i) <br>ans[<span class="hljs-string">q[now]</span>.qid] = sum(i) - sum(<span class="hljs-string">q[now]</span>.l-<span class="hljs-number">1</span>), now++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=Q; i++) <br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>\n&quot;</span>, ans[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>双倍经验 <a href="https://www.luogu.org/problemnew/show/P4113">采花</a></p>]]></content>
    
    
    <categories>
      
      <category>树状数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>粉刷匠</title>
    <link href="/2018/10/21/fs/"/>
    <url>/2018/10/21/fs/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>windy有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。</p><p>windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。</p><p>如果windy只能粉刷 T 次，他最多能正确粉刷多少格子？</p><p>一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p>输入格式：<br>第一行包含三个整数，N M T。</p><p>接下来有N行，每行一个长度为M的字符串，’0’表示红色，’1’表示蓝色。</p><p>输出格式：<br>包含一个整数，最多能正确粉刷的格子数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>分组背包与泛化背包</p><p>先对每个木板进行dp，算出每个状态前i个点刷j次最多的正确数，相当于是每个木板看成一组，有j个物品，他们互相冲突，所以只能选取其中一个。然后进行泛化背包，对第i条木板分配j个粉刷次数获得的收益是dp[m][j]，所以状态转移方程为：f[i][j]&#x3D;max(f[i][j],f[i-1][j-k]+dp[m][k])</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include &lt;iostream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">60</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>,m,<span class="hljs-built_in">T</span>;<br><span class="hljs-built_in">char</span> str[<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">N</span>],dp[<span class="hljs-built_in">N</span>][<span class="hljs-built_in">N</span>],f[<span class="hljs-built_in">N</span>][<span class="hljs-built_in">N</span>*<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> main()<br>&#123;<br>//freopen(<span class="hljs-string">&quot;fen.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;<span class="hljs-built_in">n</span>,&amp;m,&amp;<span class="hljs-built_in">T</span>);<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;i++)<br>&#123;<br>scanf(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>memset(<span class="hljs-built_in">sum</span>,<span class="hljs-number">0</span>,sizeof(<span class="hljs-built_in">sum</span>));<br>memset(dp,<span class="hljs-number">0</span>,sizeof(dp));<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-built_in">sum</span>[j]=<span class="hljs-built_in">sum</span>[j-<span class="hljs-number">1</span>]+str[j-<span class="hljs-number">1</span>]-&#x27;<span class="hljs-number">0</span>&#x27;;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">min</span>(m,<span class="hljs-built_in">T</span>);j++)<br> for(<span class="hljs-built_in">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;k++)<br>  for(<span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>;l&lt;k;l++)<br>  &#123;<br>  <span class="hljs-built_in">int</span> tot=<span class="hljs-built_in">sum</span>[k]-<span class="hljs-built_in">sum</span>[l];<br>  dp[k][j]=<span class="hljs-built_in">max</span>(dp[k][j],dp[l][j-<span class="hljs-number">1</span>]+<span class="hljs-built_in">max</span>(tot,k-l-tot));<br>  &#125;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">T</span>;j++)<br> for(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)<br>  &#123;<br>     f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i-<span class="hljs-number">1</span>][k]+dp[m][j-k]);<br>  &#125;<br>&#125;<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,f[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">T</span>]);<br>return <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>背包dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>保安站岗</title>
    <link href="/2018/10/21/ba/"/>
    <url>/2018/10/21/ba/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>五一来临，某地下超市为了便于疏通和指挥密集的人员和车辆，以免造成超市内的混乱和拥挤，准备临时从外单位调用部分保安来维持交通秩序。</p><p>已知整个地下超市的所有通道呈一棵树的形状；某些通道之间可以互相望见。总经理要求所有通道的每个端点（树的顶点）都要有人全天候看守，在不同的通道端点安排保安所需的费用不同。</p><p>一个保安一旦站在某个通道的其中一个端点，那么他除了能看守住他所站的那个端点，也能看到这个通道的另一个端点，所以一个保安可能同时能看守住多个端点（树的结点），因此没有必要在每个通道的端点都安排保安。</p><p>编程任务：</p><p>请你帮助超市经理策划安排，在能看守全部通道端点的前提下，使得花费的经费最少。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：给你一棵树，每个点有点权，可以覆盖与它相邻的节点。让你用最小的代价覆盖完整个树。</p><p>我们定义一个状态不一定要没有重复描述，只需要把所有状态描述出来没有漏掉即可</p><p>所本题我们定义状态f[u][0&#x2F;1&#x2F;2]来表示u点的3种情况：</p><ol><li><p>u点的父亲有保安</p></li><li><p>u点有保安</p></li><li><p>u点的儿子有保安</p></li></ol><p>所以我们就可以对其一个一个进行转移</p><ol><li><p>当u点的父亲有保安时，我们只需保证他的儿子都被覆盖即可，即$ f[u][0]&#x3D;\sum min(f[v][1],f[v][2])$</p></li><li><p>由于u点有保安，所以我们就并不需要关心他的父亲或儿子是否被覆盖，因此$f[u][1]&#x3D;\sum min(f[v][0],f[v][1],f[v][2])$</p></li><li><p>当u点的儿子有保安时，我们需要保证他的儿子中有一个代价最小的保安来覆盖u点，但我们并不知道儿子们的$f[v][2]$的值是怎么更新来的，万一是从v的儿子w的$f[w][2]$转移过来的呢？所以我们要比较f[v][2]和f[v][1]的大小。如果存在f[v][1]小于f[v][2]的话，那就万事大吉。但如果并没有选出一个v点使得f[v][1]小于f[v][2]，就意味着我们刚刚加上的都是f[v][2]，要使f[u][2]最小，就加上一个min(f[v][2],f[v][1])就好了。</p></li></ol><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">N</span>=<span class="hljs-number">1510</span>;<br>struct ss&#123;<br>int next,to;<br>&#125;;ss data[<span class="hljs-symbol">N</span>];<br>int n,p;<br>int head[<span class="hljs-symbol">N</span>],f[<span class="hljs-number">3</span>][<span class="hljs-symbol">N</span>],w[<span class="hljs-symbol">N</span>],du[<span class="hljs-symbol">N</span>];<br>void add(int a,int b)<br>&#123;<br>data[++p].next=head[a];<br>data[p].to=b;<br>head[a]=p;<br>&#125;<br>void dfs(int u)<br>&#123;<br>//printf(<span class="hljs-string">&quot;%d\n&quot;</span>,u);<br>f[<span class="hljs-number">0</span>][u]=f[<span class="hljs-number">1</span>][u]=<span class="hljs-number">0</span>;<br>int flag=<span class="hljs-number">0</span>;<br>f[<span class="hljs-number">2</span>][u]=w[u];<br>int cha=<span class="hljs-number">0x3f3f3f3f</span>;<br>for(int i=head[u];i;i=data[i].next)<br>&#123;<br>int v=data[i].to;<br> dfs(v);<br>f[<span class="hljs-number">2</span>][u]+=min(min(f[<span class="hljs-number">0</span>][v],f[<span class="hljs-number">1</span>][v]),f[<span class="hljs-number">2</span>][v]);<br>f[<span class="hljs-number">0</span>][u]+=min(f[<span class="hljs-number">2</span>][v],f[<span class="hljs-number">1</span>][v]);<br>if(f[<span class="hljs-number">2</span>][v]&lt;f[<span class="hljs-number">1</span>][v])<br>flag=<span class="hljs-number">1</span>;<br>else <br>&#123;<br>   cha=min(cha,f[<span class="hljs-number">2</span>][v]-f[<span class="hljs-number">1</span>][v]);<br>    &#125;<br>f[<span class="hljs-number">1</span>][u]+=min(f[<span class="hljs-number">2</span>][v],f[<span class="hljs-number">1</span>][v]);<br><br>&#125;<br>if(flag==<span class="hljs-number">0</span>)<br>   f[<span class="hljs-number">1</span>][u]+=cha;<br>&#125;<br>int main()<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>int root,son,v,val;<br>scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;root,&amp;val,&amp;son);<br>w[root]=val;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=son;j++)<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;v);du[v]++;<br>add(root,v);<br>&#125;<br>&#125;<br>memset(f,<span class="hljs-number">0</span>,sizeof(f));<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>if(!du[i])<br>&#123;<br>   dfs(i);<br>   printf(<span class="hljs-string">&quot;%d\n&quot;</span>,min(f[<span class="hljs-number">2</span>][i],f[<span class="hljs-number">1</span>][i]));<br>    &#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（加强版）现在想一想，如果要统计有多少种方案数呢？</p><p>放一个代码</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;cstdio&gt;<br>#include &lt;algorithm&gt;<br>#define <span class="hljs-symbol">N</span> <span class="hljs-number">500010</span><br>#define mod <span class="hljs-number">1032992941</span>ll<br>using namespace std;<br>typedef long long ll;<br>int head[<span class="hljs-symbol">N</span>] , to[<span class="hljs-symbol">N</span> &lt;&lt; <span class="hljs-number">1</span>] , next[<span class="hljs-symbol">N</span> &lt;&lt; <span class="hljs-number">1</span>] , cnt;;<br>ll fa[<span class="hljs-symbol">N</span>] , f1[<span class="hljs-symbol">N</span>] , f2[<span class="hljs-symbol">N</span>] , f3[<span class="hljs-symbol">N</span>] , s1[<span class="hljs-symbol">N</span>] , s2[<span class="hljs-symbol">N</span>] , s3[<span class="hljs-symbol">N</span>];<br>void add(int x , int y)<br>&#123;<br>to[++cnt] = y , next[cnt] = head[x] , head[x] = cnt;<br>&#125;<br>void dfs(int x)<br>&#123;<br>int i , ft;<br>ll st;<br>f1[x] = s1[x] = s2[x] = s3[x] = <span class="hljs-number">1</span> , f2[x] = <span class="hljs-symbol">N</span>;<br>for(i = head[x] ; i ; i = next[i])<br>&#123;<br>if(to[i] != fa[x])<br>&#123;<br>fa[to[i]] = x , dfs(to[i]);<br>ft = min(f1[to[i]] , min(f2[to[i]] , f3[to[i]])) , st = <span class="hljs-number">0</span>;<br>if(f1[to[i]] == ft) st += s1[to[i]];<br>if(f2[to[i]] == ft) st += s2[to[i]];<br>if(f3[to[i]] == ft) st += s3[to[i]];<br>f1[x] += ft , s1[x] = s1[x] * st <span class="hljs-comment">% mod;</span><br>ft = min(min(f2[x] + f1[to[i]] , f2[x] + f2[to[i]]) , f3[x] + f1[to[i]]) , st = <span class="hljs-number">0</span>;<br>if(f2[x] + f1[to[i]] == ft) st += s2[x] * s1[to[i]] <span class="hljs-comment">% mod;</span><br>if(f2[x] + f2[to[i]] == ft) st += s2[x] * s2[to[i]] <span class="hljs-comment">% mod;</span><br>if(f3[x] + f1[to[i]] == ft) st += s3[x] * s1[to[i]] <span class="hljs-comment">% mod;</span><br>f2[x] = ft , s2[x] = st <span class="hljs-comment">% mod;</span><br>f3[x] += f2[to[i]] , s3[x] = s3[x] * s2[to[i]] <span class="hljs-comment">% mod;</span><br>&#125;<br>&#125;<br>&#125;<br>int main()<br>&#123;<br>int n , i , x , y;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span> , &amp;n);<br>for(i = <span class="hljs-number">1</span> ; i &lt; n ; i ++ ) scanf(<span class="hljs-string">&quot;%d%d&quot;</span> , &amp;x , &amp;y) , add(x , y) , add(y , x);<br>dfs(<span class="hljs-number">1</span>);<br>if(f1[<span class="hljs-number">1</span>] &lt; f2[<span class="hljs-number">1</span>]) printf(<span class="hljs-string">&quot;%lld\n%lld\n&quot;</span> , f1[<span class="hljs-number">1</span>] , s1[<span class="hljs-number">1</span>]);<br>else if(f1[<span class="hljs-number">1</span>] &gt; f2[<span class="hljs-number">1</span>]) printf(<span class="hljs-string">&quot;%lld\n%lld\n&quot;</span> , f2[<span class="hljs-number">1</span>] , s2[<span class="hljs-number">1</span>]);<br>else printf(<span class="hljs-string">&quot;%lld\n%lld\n&quot;</span> , f1[<span class="hljs-number">1</span>] , (s1[<span class="hljs-number">1</span>] + s2[<span class="hljs-number">1</span>]) <span class="hljs-comment">% mod);</span><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>树形dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排列</title>
    <link href="/2018/10/21/pl/"/>
    <url>/2018/10/21/pl/</url>
    
    <content type="html"><![CDATA[<h3 id="洛谷-P4163-SCOI2007-排列"><a href="#洛谷-P4163-SCOI2007-排列" class="headerlink" title="洛谷 P4163 [SCOI2007]排列"></a>洛谷 P4163 [SCOI2007]排列</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个数字串s和正整数d, 统计s有多少种不同的排列能被d整除（可以有前导0）。例如123434有90种排列能</p><p>被2整除，其中末位为2的有30种，末位为4的有60种。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>状态压缩，用S来表示第几位用没用，i表示余数是多少，自然而然想到方程式：$f[S|(1&lt;&lt;(j-1)][(i*10+j) \mod d]+&#x3D;f[S][i]$，好像很简单四不四？</p><p>然鹅写上去发现样例都过不了，why？因为没有去重，蒟蒻想了好几分钟才反应过来应该除以每个数出现次数的阶乘，为什么呢？因为我们对每一种排列都统计了他的全排列的次数，所以要这么干啦！</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t,len,d;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">11</span>],af[<span class="hljs-number">15</span>];<br>ll f[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>][<span class="hljs-number">1200</span>];<br><span class="hljs-type">int</span> A[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>,<span class="hljs-number">3628800</span>&#125;;<br><span class="hljs-type">char</span> in[<span class="hljs-number">111</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,in,&amp;d);<br>        len = <span class="hljs-built_in">strlen</span>(in);<br>        <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>            af[i] = in[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            cnt[af[i]]++;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(f));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;len);i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;d;j++)&#123;<br>                <span class="hljs-keyword">if</span>(f[i][j])&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;len;k++)&#123;<br>                        <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;k))==<span class="hljs-number">0</span>)&#123;<br>                            f[i|(<span class="hljs-number">1</span>&lt;&lt;k)][(j*<span class="hljs-number">10</span>+af[k<span class="hljs-number">+1</span>])%d]+=f[i][j];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)<br>            <span class="hljs-keyword">if</span>(cnt[i])<br>                f[(<span class="hljs-number">1</span>&lt;&lt;len)<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]/=A[cnt[i]];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,f[(<span class="hljs-number">1</span>&lt;&lt;len)<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>状态压缩</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HOT-Hotels</title>
    <link href="/2018/10/21/HOT/"/>
    <url>/2018/10/21/HOT/</url>
    
    <content type="html"><![CDATA[<h2 id="P3565-POI2014-HOT-Hotels"><a href="#P3565-POI2014-HOT-Hotels" class="headerlink" title="P3565 [POI2014]HOT-Hotels"></a>P3565 [POI2014]HOT-Hotels</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个树形结构，每条边的长度相同，任意两个节点可以相互到达。选3个点。两两距离相等。有多少种方案？</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意就不说了吧….</p><p>好像是个dp？</p><p>又好像是个数数？</p><p>管他的，画画图再说</p><p>我们知道三个点之间距离两两相等的话，必有一个交汇点，那我们枚举这个交汇点为根，方案就是各个子树中深度相同的点的组合。</p><p>OK，那我们怎么统计呢？</p><p>假设我们现在有三个子树，他们在某一深度的点数为$a,b,c$,那么方案数为$a \times b \times c$。</p><p>现在我们又来了一棵子树，在这一深度的点数为$d$,那么显然方案数会变为$a \times b \times c+a \times b  \times d+a \times c  \times d+b \times c  \times d$，增长了$a \times b \times d+a \times c \times d+b \times c \times d$，即$d \times (a \times b+a \times c+b \times c)$。</p><p>如果再来一个$e$呢？增长了$e \times (a \times b+a \times c+b \times c+a \times d+b \times d+c \times d)$</p><p>所以我们发现了什么?我们设$sigma1&#x3D;a \times b+a \times c+a \times d…$那一坨，那么答案增长就是$sigma1 \times i$（$i$为新加节点数），那$sigma1$怎么算呢？</p><p>我们观察一下$sigma1$的变化情况，发现从加入$d$到加入$e$时增加了$d \times (a+b+c)$，嗯…..有意思吧？就是之前的总的点数乘以新加的节点数，所以加一个$sigma2$维护一下即可，伪代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sigma1 += sigma2  *  size[k];<br>sigma2 += size[k]<br></code></pre></td></tr></table></figure><p>真正的代码（代码中$sigma1$和$sigma2$的意义与题解相反）</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span>&#123;<br><span class="hljs-type">int</span> next,to;<br>&#125;;ss data[N*<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> n,maxdep,p;<br><span class="hljs-type">int</span> head[N],dep[N],size[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans,sigma1[N],sigma2[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>data[++p].next = head[a];<br>data[p].to = b;<br>head[a] = p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>maxdep = <span class="hljs-built_in">max</span>(maxdep,dep[a]);<br>size[dep[a]]++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[a]; i; i = data[i].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[i].to;<br><span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>dep[v] = dep[a]<span class="hljs-number">+1</span>;<br><span class="hljs-built_in">dfs</span>(v, a);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n<span class="hljs-number">-1</span>; ++i)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br><span class="hljs-built_in">add</span>(u, v);<span class="hljs-built_in">add</span>(v, u);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>&#123;<br><span class="hljs-built_in">memset</span>(sigma1,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sigma1));<br><span class="hljs-built_in">memset</span>(sigma2,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sigma2));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[i]; j; j = data[j].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[j].to;<br><span class="hljs-built_in">memset</span>(dep,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dep));<br>dep[v] = <span class="hljs-number">1</span>;<br>maxdep = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs</span>(v,i);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= maxdep; ++k)<br>&#123;<br><span class="hljs-comment">//printf(&quot;%d\n&quot;,size[k]);</span><br>ans += sigma2[k] * size[k];<br>sigma2[k] += sigma1[k] * size[k];<br>sigma1[k] += size[k];<br>size[k] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>树形dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈利波特与死亡圣器</title>
    <link href="/2018/10/21/horry/"/>
    <url>/2018/10/21/horry/</url>
    
    <content type="html"><![CDATA[<h2 id="BZOJ-5174-Jsoi2013-哈利波特与死亡圣器"><a href="#BZOJ-5174-Jsoi2013-哈利波特与死亡圣器" class="headerlink" title="BZOJ 5174 [Jsoi2013]哈利波特与死亡圣器"></a>BZOJ 5174 [Jsoi2013]哈利波特与死亡圣器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完<br>成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡<br>圣器，伏地魔将必死无疑。在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他<br>很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的<br>战斗。霍格沃茨魔法学校的主要建筑共有n处，我们编号为1到n，这些建筑间由魔法道路连接，整体呈树状分布，<br>即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑<br>自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保<br>卫建筑。现在，伏地魔大军已经到达1号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门<br>的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，<br>随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前<br>往已经攻克的建筑）。目前除了1号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建<br>筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的<br>启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已<br>经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。<br>请你计算，至少需要派出多少位成员。</p><p>注：<br>（1）伏地魔大军到达1号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。</p><p>（2）当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情<br>况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。</p><p>（3）已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回<br>到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题意：给你一棵以1为根的有根树，初始除了1号点为黑色外其余点均为白色。Bob初始在1号点。每次Alice将其中至多k个点染黑，然后Bob移动到任意一个相邻节点，重复这个过程。求最小的k，使得无论Bob怎样移动，经过的节点都是黑色节点。</p><p>首先我们可以看出我们优先要堵叶子节点，这k个人每次可能将叶子节点全部覆盖甚至多余出来，也有可能不够填满需要之前多余出来的人预先来堵。</p><p>很显然答案是满足单调性的吧?</p><p>于是我们用树形dp来判断</p><p>我们二分一个$k$。用$f[i]$表示走到$i$节点下一轮要符合条件我们额外需要的人数，$size$表示子节点数量。那么状态转移就是$f[i]&#x3D;max(size[i]-k+ \sum f[son[i]],0)$，如果为负即表示不需要额外分配人数，把它置为0。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-meta">#include &lt;stdio.h&gt;</span><br><span class="hljs-meta">#include &lt;cstring&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>const <span class="hljs-type">int</span> N=<span class="hljs-number">300010</span>;<br>struct ss&#123;<br><span class="hljs-type">int</span> next,<span class="hljs-keyword">to</span>;<br>&#125;;ss data[N&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> n,p,ans;<br><span class="hljs-type">int</span> head[N],son[N],f[N];<br><span class="hljs-type">void</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)<br>&#123;<br>data[++p].next = head[a];<br>data[p].<span class="hljs-keyword">to</span> = b;<br>head[a] = p;<br>&#125;<br><span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> fa)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[a]; i;i = data[i].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[i].<span class="hljs-keyword">to</span>;<br><span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>son[a]++;<br>dfs(v,a);<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> dp(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> li)<br>&#123;<br>f[a] = son[a] - li;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[a]; i;i = data[i].next)<br>&#123;<br><span class="hljs-type">int</span> v = data[i].<span class="hljs-keyword">to</span>;<br><span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>dp(v,a,li);<br>f[a] += f[v];<br>&#125;<br>f[a]=max(f[a],<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">int</span> main()<br>&#123;<br>scanf(&quot;%d&quot;,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n<span class="hljs-number">-1</span>; ++i)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br>scanf(&quot;%d%d&quot;,&amp;u, &amp;v);<br><span class="hljs-keyword">add</span>(u, v);<span class="hljs-keyword">add</span>(v, u);<br>&#125;<br>dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>//printf(&quot;ysj\n&quot;);<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n;<br><span class="hljs-keyword">while</span>(l&lt;=r)<br>&#123;<br>//printf(&quot;%d %d\n&quot;,l,r);<br><span class="hljs-type">int</span> mid = l +r &gt;&gt;<span class="hljs-number">1</span>;<br>dp(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,mid);<br><span class="hljs-keyword">if</span>(f[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)<br>&#123;<br>ans=mid;<br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>l=mid+<span class="hljs-number">1</span>;<br>&#125;<br>printf(&quot;%d\n&quot;,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>树形dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宝箱</title>
    <link href="/2018/10/21/trea/"/>
    <url>/2018/10/21/trea/</url>
    
    <content type="html"><![CDATA[<h2 id="洛谷-P3004-USACO10DEC-宝箱Treasure-Chest"><a href="#洛谷-P3004-USACO10DEC-宝箱Treasure-Chest" class="headerlink" title="洛谷 P3004 [USACO10DEC]宝箱Treasure Chest"></a>洛谷 P3004 [USACO10DEC]宝箱Treasure Chest</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>贝西和伯尼找到了一个装满了金币的宝箱！但是，作为奶牛，他们不能随便进入一家商店去买东西。所以他们决定去用这些金币玩一个游戏。</p><p>这里有N（1&lt;&#x3D;N&lt;&#x3D;5000）个硬币，每个都有一个价值C_i（1&lt;&#x3D;C_i&lt;&#x3D;5000）。这些硬币被摆成了一行。贝西和伯尼每人一回合。到了一只奶牛的回合时，他就要拿走最左边或者最右边的硬币。当没有硬币时，游戏结束。</p><p>贝西和伯尼都想要使自己拿到的金币价值尽量高，贝西先拿。现在贝西想要你帮帮她，算出她最多可以拿多少钱（伯尼也会尽量取到最优）。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>区间dp，用$f[i][j]$表示两个人取$i$到$j$这个区间能取到的最大值。</p><p>考虑转移：我们想，在区间确定的情况下，如果要取得最大，那么另一个人取得他最优策略的最小值，那么即可写出状态转移方程：$f[i][j] &#x3D; sum[j] - sum[i - 1] - min(f[i + 1][j], f[i][j +1])$，遗憾的是空间开不下，所以滚一维就好了。</p><p>第一次写区间dp的滚动</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N][<span class="hljs-number">3</span>], sum[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>&#123;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>   sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>   f[i][<span class="hljs-number">1</span>] = a[i];<br>&#125;<br><span class="hljs-type">int</span> bas = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; ++i)<br>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>;i + l - <span class="hljs-number">1</span> &lt;= n; ++l)<br> &#123;<br> <span class="hljs-type">int</span> r = l + i - <span class="hljs-number">1</span>;<br> f[l][bas] = sum[r] - sum[l - <span class="hljs-number">1</span>] - <span class="hljs-built_in">min</span>(f[l][bas ^ <span class="hljs-number">1</span>], f[l + <span class="hljs-number">1</span>][bas ^ <span class="hljs-number">1</span>]);<br> &#125;<br> bas ^= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][bas ^ <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Noip倒计时</title>
    <link href="/2018/10/21/io/"/>
    <url>/2018/10/21/io/</url>
    
    <content type="html"><![CDATA[<p>遵循<del>狒狒</del>匪匪的要求，写下这篇noip倒计时日志</p><h3 id="10-15"><a href="#10-15" class="headerlink" title="10.15"></a>10.15</h3><p>OL竟然没有考试（说好的加大马力呢….），看了一上午加一下午的noip模拟题（沉迷于杭州学军的模拟题无法自拔）。</p><p>对一道多重背包上下其手搞了一道自以为很毒瘤的题粗来，结果先是数据出锅，然后被芝麻糊糊爆搜搜过去了…..懒得加强数据，就更加毒瘤地把时限开成了100ms（雾），成功把芝麻糊糊的爆搜卡成了0分。（手动滑稽）</p><p>晚上十分挫地被一道noip模拟题的t1卡了很久，当快要放弃人生时发现答案很小？可以暴力枚举？然后二进制优化检验就行了？….窝还是太菜了啊啊啊。</p><p>自以为字符串dp很差就去看了几道题，然后发现果然做不粗来….疯狂颓废颓废….然后发现暴力匹配暴力刷表可过？</p><p>晚上在朋友博客上注册了一个账号，把tarjan搬上去镇楼，从洛谷图床搬图真是累死…..以后题解再也不用洛谷图床了…..</p><h3 id="10-16"><a href="#10-16" class="headerlink" title="10.16"></a>10.16</h3><p>OL考试了！</p><p>群里面czt才冷静分析一波，觉得还没有过危险期，记过OL就清了清嗓子：“好嘛，把座位调一蛤哈。”</p><p>十分虚地换了位置，又十分虚地拷了题，又十分虚地调配置（结果什么都没有调好），OL就断网了。</p><p>OL关上门，“密码是6个3蛤。”</p><p>2333333</p><p>开了题，看T1，滑稽？什么鬼？等等…这题我好像在哪见过。</p><p>然后意识到是暑假上来前一队的考试题，我去找hdxrie要了题，看了看，感觉有点难就跑了。</p><p>所以好像并没有什么影响？</p><p>做题吧。</p><p>T1如果把四人组两两合并起来拿个东西来装一下数量就可以了？那就用hash表吧。链表？四个操作不好写，还是用vector吧（爆炸伏笔）。刷刷刷，中途取膜炸掉了，换成233333，一发写过，自信不拍。</p><p>T2是个dp？嗯。好像很水，直接用个结构体记录这个时间点最大AC数和满足最大AC数的剩下的代码行数就行了，30min写过，自信不拍。</p><p>T3是个爆搜？完了完了，不想写，我今天应该有200了吧，<del>不为100分向爆搜折腰</del>，我今天就是死，死外边，从这里跳下去也不写爆搜题！水了五分钟，哎哟，这题贼难。</p><p>写写写，感觉要码到世界尽头，搞了1个多小时才过了样例，嗯，25分应该有了吧。</p><p>预估100+100+？</p><p>然后就水水水…..</p><p>评测先测T2，嗯，A了，很稳。到了T1，What?超时了？逗我？又到了T3，错完了。GG。</p><p>结果突然想起OL的老爷机卡各种STL容器。</p><p>多么痛的领悟….</p><p>下午改题，10分钟改完T1，随便改了改T3，水了75分心满意足不想搞了。就去看了看hdxrie给我的noip模拟，T1这是啥啊？推式子？推推推，推了30min，退不粗来了，还是太菜了啊。</p><p>想了一个小时磨不出来，看了下std，一眼秒懂——这不是矩阵快速幂优化递推吗？话说好久没做这种题了，得练练啊。</p><p>晚上练字符串dp和矩阵，搞了半天，发现找不到什么好题…..跑去找imagine，imagine推荐了租酥雨….那就上吧！</p><h3 id="10-17"><a href="#10-17" class="headerlink" title="10.17"></a>10.17</h3><p>没有考试</p><p>怒刷3道租酥雨博客</p><p>更加感受到自己还需要提升的地方</p><p>晚上搞图论，被洛谷标签蛊惑，被星际贸易卡了半个晚上，才发现是个单调队列优化dp。</p><h3 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h3><p>OL今天考noip真题？</p><p>曾经以为noip2016是最难的一年，今天一考，100+55+96 &#x3D; 251？</p><p>感觉自己要不是t3偷懒把答案扔到转移里一起更新没有考虑n&#x3D;1的情况第一天就能一等（逃）</p><p>果然做过的题就是不一样。</p><p>最难的永远是今年</p><p>被aoweiyin推荐的毒瘤找规律卡到了晚上8点过，其余时间全在改天天爱跑步，<del>还是没有改出来</del>，有点小难受。</p><h3 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h3><p>因为某种原因咕咕了几天（<del>其实是因为懒</del>）</p><p>今天考的是noip2017（搞不懂为什么要一直靠&#x3D;考原题）</p><p>想起去年noipDAY1差点爆零这一悲惨经历，决定要一雪前耻！（flag）</p><p>考题在解压前我就把T1写好了……..</p><p>该死的结论题去年卡了我好久都没有看出来</p><p>T2才是一年的梦魇，去年字符读入一直有问题，搞得我头皮发麻，于是之前刷noip时一直选择跳过，今天还是逃不过了。</p><p>那就写吧……等等，我好像会写了…….嗯，应该没问题，就是这样。</p><p>T3去年打了个最短路计数没有清空图一分没得……今年反手一个记搜，自信不拍。</p><p>我应该Ak了吧23333…..</p><p>考完后提前把代码交到洛谷上，发现T2CE了！</p><p>然后我发现了我的time变量…..</p><p>GG了</p><p>DAY1200滚粗了</p><p>下午把三道题的题解写了，无所事事地闲逛，刷题，感jio状态很差。调整了好一会儿才反应过来我四不四没救了啊……</p><p>晚上有个天真的小学弟来问题，十分认真地说出了“数据结构不是很简单吗？”一起了众人的愤懑。imagin拿出了10kb的计算几何，大帅王者拿出了红黑树…..一群人去嘲讽人家，直播聊天。吓得他直接溜到akb那里嘤嘤嘤了QAQ</p><h3 id="10-24"><a href="#10-24" class="headerlink" title="10.24"></a>10.24</h3><p>又是没有考试的颓废的一天。</p><p>上午把租酥雨刷题计划上能做题都搞了，才发现自己能做的好像还真没几道QAQ，然后继续跟踪yyb，顺便%%GXZ</p><p>下午听OL讲noip2015年DAY2。翻了翻洛谷，这三道我都做过了耶，那就更博客吧。更了几篇，发现OL在讲T3于是饶有兴致地听了听。</p><p>OL：“我想了一蛤，我jio得这个题考得就是你对dfs的理解蛤”</p><p>然后他就讲了好久如何O(n)的一次搜索得到LCA，听他balabala了好久的tarjan，晕头转向。半个多小时后，终于讲完tarjan了，我抬起了头，盯着OL，想听他如何用dfs解决这道我用了二分+差分+倍增求LCA的神题。</p><p>OL望了望四周：“听懂了没有？”（懂了懂了，你快讲）</p><p>“那就回去在mei一蛤嘛”</p><p>？</p><p>啥，就完了？一道二分+差分+倍增求LCA的神题你就讲一下如何O(n)就LCA？………</p><p>有点懵圈。</p><p>晚上刷差分，被一道神题恶心了好久，被Bug哥说可以用二阶差分秒杀。</p><p>二阶差分是啥?喵喵喵？</p><p>看了一会儿二阶差分，写了到模板题2，在来看那道神题…….怎么二阶差分啊，搞不了啊……我还是太菜了……</p><p>结果Bug哥放学的时候给我说二阶差分做不了。</p><p>233333</p><h3 id="10-25"><a href="#10-25" class="headerlink" title="10.25"></a>10.25</h3><p>OL竟然没有考试？</p><p>那就刷题吧，黄学长六百多道BZOJ的题可以试试能搞多少</p><p>然后….上午下午晚上都在刷黄学长去了</p><p>下午体检，结果两个负责人都没有去拿体检单在那里面面相觑。搞了半天就在体检处。去测身高体重发现只长高了1cm，体重还没变？鬼知道这一年我在南山干了什么……</p><p>晚上完成了博客的最后一步，现在终于可以宣告完成啦。</p><h3 id="10-26"><a href="#10-26" class="headerlink" title="10.26"></a>10.26</h3><p>OL还不考试…..</p><p>早上被黄学长的一道题卡到了10点，芝麻糊糊又过来问了一道noip模拟，叫什么多愁伤感的xxx？先自己想想吧，想想想，嗯，把区间膜一下排除掉就可以了？懒得打，就去看标程，好像没什么毛病，等等，今天上午就过了？</p><p>下午给芝麻糊糊讲了一下，被她问得一愣一愣的，窝还是太菜了2333。<br>继续刚黄学长的题，开三道就是两道网络流，剩下一道毒瘤数学题，无从下手…..写了2个题，就把一个下午给颓掉了。</p><p>晚上有牛客网比赛？去打一下（其实是想混个T恤）。</p><p>膜法师？有意思</p><p>第一题水题直接n根号n秒切</p><p>第二题就卡住了，仙人掌？然鹅只知道定义，并不知道任何性质。乱搞一下，n&#x3D;1时直接1，其余二分图匹配，成功就是2，失败就是3，应该不会有4色吧……然后就A掉了</p><p>第三题…..树形dp？看起来很麻的样子，刚一下…..刚到了最后都没有调出来，最后才发现有个细节搞错了，两百多名滚粗。</p><p>以后写题时思路一定要清晰了才动手</p><h3 id="10-27"><a href="#10-27" class="headerlink" title="10.27"></a>10.27</h3><p>OL竟然又要考试了？</p><p>还以为是2017day2，结果一打开题，面如死灰，by kiana。</p><p>第一题是个什么鬼东西，一大坨矩阵求并？记个最大次大？来一发试试。调调调，搞到了10点才过了大样例。</p><p>还有一半的时间，果断写暴力，10点40时搞完暴力，无所事事，看了看T3的前5个点好像数位dp很可做的样子，然后就一直写写写，结果因为某种莫名其妙的原因gg掉了。</p><p>我第一题应该没问题吧……</p><p>中午来看成绩，82？T1炸了？czt给我说用前缀后缀并起来搞一下就行了……结果凤姐用扫描线A掉了。</p><p>T3不应该只有12的呀….结果回来一看，才发现没有取膜……</p><p>取膜取膜取膜！</p><h3 id="10-28"><a href="#10-28" class="headerlink" title="10.28"></a>10.28</h3><p>上午早早到机房<del>c</del>，周卓的比赛切了T1就不想搞了，T2感觉很奇葩，T3叫忘情？忘情水二分？题目提示算法？有意思。听说后面的题还有毒瘤，就不打算做了，颓废颓废。</p><p>下午收钱收死个人，毒瘤28块，找零真是要命。</p><p>晚上打牛客网，T1大爆搜记录答案懒得离散化直接二分查找区间，然后T2看错题没看到是个环以为是情侣给我烧了的变种，就死掉了，最后极限一个暴力骗了20。</p><p>20名和26名的T恤，我23……</p><h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><p>再次由于某种原因咕咕了几天。（主要是考太差了不敢写）</p><p>早上填了一下素数筛法的坑，想起周末跟朋友讨论的那个题把它写了出来，下午刷状压，被一双木棋的轮廓线卡了好久才调出来。</p><p>晚上有人来跟我说我的题有原题？</p><p>不会吧…..</p><p>嗯？老唐又骗我？我想了想，周末我们讨论了一会十分复杂地各种技能各种伤害的补兵，结果发现有点困难，他突然神秘兮兮地给我说：“那看看这样子，就是把伤害都看成1的话，就可做了。”于是我一直想到了周二还是没有想出来，只好找他要题解，然后出成了题…….结果撞车了2333333，身败名裂。</p><p>回去得把他红烧一顿了。</p><p>晚上因为撞题心里一直很慌，只切了一道傻逼状压，以后还是少bb几句吧…..</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>道路</title>
    <link href="/2018/10/20/road/"/>
    <url>/2018/10/20/road/</url>
    
    <content type="html"><![CDATA[<h2 id="洛谷-P4438-HNOI-AHOI2018-道路"><a href="#洛谷-P4438-HNOI-AHOI2018-道路" class="headerlink" title="洛谷 P4438 [HNOI&#x2F;AHOI2018]道路"></a>洛谷 P4438 [HNOI&#x2F;AHOI2018]道路</h2><p>题目大意：给你一颗二叉树，部分点有一个点权为$c[i]  \times  (a[i] + x)  \times  (b[i] + y)$，$x,y$为这个点到根节点的路径上没有选择的左边与右边的数量，现在让你在选择$n - 1$条边，使得总的点权最小。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一眼树形dp，我们定义$f[u][i][j]$表示u点到根节点的路径上有i条公路和j条铁路时它的子树的最小点权和。</p><p>考虑转移：我们可以选择覆盖u的公路，那么就从$f[left][i][j] + f[right][i][j + 1]$转移过来，如果选择标记u的铁路，那么就从$f[left][i + 1][j] + f[right][i]][j]$转移过来、</p><p>嗯…好像很简单？</p><p>不！你发现$n&#x3D;20000$，空间开不下！</p><p>怎么办？我们发现我们转移时每个点只用了一次子节点，它的更新是沿着一条链向上更新的，所以我们可以用一个$dfn$给每个点编一个号，比如$u$点的$dfn$是$now$，那么子节点就是$now + 1$和$now + 2$，我们发现由于转移时只涉及一次子节点，所以它的状态不会重复或者冲突。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dfn[N &lt;&lt; <span class="hljs-number">1</span>], son[N &lt;&lt; <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>LL f[<span class="hljs-number">110</span>][<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], a[N &lt;&lt; <span class="hljs-number">1</span>], b[N &lt;&lt; <span class="hljs-number">1</span>], c[N &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>dfn[u] = d;<br><span class="hljs-keyword">if</span>(u &gt; n - <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= l; ++i)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= r; ++j)<br>  f[dfn[u]][i][j] = <span class="hljs-number">1ll</span> * c[u] * (a[u] + i) * (b[u] + j);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(son[u][<span class="hljs-number">0</span>], d + <span class="hljs-number">1</span>, l + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">dfs</span>(son[u][<span class="hljs-number">1</span>], d + <span class="hljs-number">2</span>, l, r + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= l; ++i)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= r; ++j)<br> f[dfn[u]][i][j] = <span class="hljs-built_in">min</span>(f[dfn[son[u][<span class="hljs-number">0</span>]]][i + <span class="hljs-number">1</span>][j] + f[dfn[son[u][<span class="hljs-number">1</span>]]][i][j], f[dfn[son[u][<span class="hljs-number">0</span>]]][i][j] + f[dfn[son[u][<span class="hljs-number">1</span>]]][i][j + <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n - <span class="hljs-number">1</span>; ++i)<br>&#123;<br><span class="hljs-type">int</span> s, t;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);<br>son[i][<span class="hljs-number">0</span>] = s &gt; <span class="hljs-number">0</span> ? s : -s + n - <span class="hljs-number">1</span>;<br>son[i][<span class="hljs-number">1</span>] = t &gt; <span class="hljs-number">0</span> ? t : -t + n - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a[i + n - <span class="hljs-number">1</span>], &amp;b[i + n - <span class="hljs-number">1</span>], &amp;c[i + n - <span class="hljs-number">1</span>]);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>树形dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神奇的-1/12</title>
    <link href="/2018/10/20/magic/"/>
    <url>/2018/10/20/magic/</url>
    
    <content type="html"><![CDATA[<p>相信大家都看见过这样一个玄学的式子<br>$$<br>1 + 2 + 3 + 4 + … &#x3D; \frac{1}{-12}<br>$$<br>$what?$一群正数相加得到了一个负数？神经病吧</p><p>然而就是这个式子结果在复分析、量子力学及弦理论等领域中有所应用。</p><p>所以你就好奇了，这玩意儿怎么证明呢？</p><p>我们来试试</p><p>首先先看一个式子</p><blockquote><p>$$<br>S1 &#x3D; 1-1+1-1+1-1+…..<br>$$</p></blockquote><p>这个式子等于多少？</p><p>答案是$\frac{1}{2}$</p><p>….那这个怎么证呢？</p><p>你可以编一个故事：$Danny$在抛硬币，抛到正面得一分，反面扣一分，那么他抛了$n$多次后他的得分会趋近于多少？</p><p>根据概率期望的计算，我们可以得到是$\frac{1}{2}$</p><p>当然你也可以黏密地证明</p><blockquote><p>$1 - S1 &#x3D; 1-(1-1+1-1+1-1+1-…….) $</p></blockquote><blockquote><p>$&#x3D;1-1+1-1+1-1+…..&#x3D;S1$</p></blockquote><blockquote><p>$\Rightarrow2*S1 &#x3D; 1$</p></blockquote><blockquote><p>$\Rightarrow S1 &#x3D; \frac{1}{2}$</p></blockquote><p>$OK$，解决了这个问题，我们再来看这个式子</p><blockquote><p>$S2 &#x3D; 1 - 2 + 3 - 4 + 5 - 6 + 7 - …..$</p></blockquote><p>这个式子怎么求呢？</p><p>我们可以看出$S2$他的相邻项有着某种微妙的关系，所以我们可以这样</p><blockquote><p>$2 * S2 &#x3D; (1- 2+3-4+5-6+7…..)+$</p></blockquote><blockquote><p>$\quad\quad\quad\quad\quad\quad(1-2+3-4+5-6……)$</p></blockquote><blockquote><p>$\Rightarrow2*S2 &#x3D; 1-1+1-1+1-1….&#x3D;S1$</p></blockquote><blockquote><p>$\Rightarrow2*S2 &#x3D; \frac{1}{2}-&gt;S2&#x3D;\frac{1}{4}$</p></blockquote><p>好了，万事俱备，我们可以来算开始的那个式子$S$了</p><blockquote><p>$S-S2&#x3D;0+4+0+8+0+12+0+16+……$</p></blockquote><blockquote><p>$\Rightarrow&#x3D;4*(1+2+3+4+5+……)&#x3D;4*S$</p></blockquote><blockquote><p>$\Rightarrow S&#x3D;-\frac{1}{3}S2&#x3D;-\frac{1}{12}$</p></blockquote><p>证毕</p><p>四不四很简单啊！撒花！</p><p>当然，实际上以上内容纯属扯淡，因为很明显$1+2+3+4+5+….$这个式子是不收敛的，所以算它的值的各种蛇皮变换也是不符合规则的，所以…..这玩意儿只适合在萌新中装逼使用（逃）</p>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虔诚的墓主人</title>
    <link href="/2018/10/20/zjyAKIOI/"/>
    <url>/2018/10/20/zjyAKIOI/</url>
    
    <content type="html"><![CDATA[<h2 id="SDOI2009-虔诚的墓主人"><a href="#SDOI2009-虔诚的墓主人" class="headerlink" title="[SDOI2009]虔诚的墓主人"></a>[SDOI2009]虔诚的墓主人</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小W是一片新造公墓的管理人。公墓可以看成一块N×M的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。</p><p>当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。</p><p>一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好k棵常青树。</p><p>小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。</p><p>对于30%的数据，满足1 ≤ N, M ≤ 1,000。</p><p>对于60%的数据，满足1 ≤ N, M ≤ 1,000,000。</p><p>对于100%的数据，满足1 ≤ N, M ≤ 1,000,000,000，0 ≤ xi ≤ N，0 ≤ yi ≤ M，1 ≤ W ≤ 100,000，1 ≤ k ≤ 10。</p><p>存在50%的数据，满足1 ≤ k ≤ 2。</p><p>存在25%的数据，满足1 ≤ W ≤ 10000。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>给你一个矩形，里面有一些物品，求这些物品构成的边长为k的十字架的数目</p><p>首先我们可以得出一个式子</p><p>$ans &#x3D; \sum C[l(x,y)][k] * C[r(x,y)][k] * C[u(x,y)][k]*C[d(x,y)][k]$</p><p>其中$l,r,u,d$，表示$(x,y)$点左边，右边，上边和下边有多少个物品。</p><p>最自然的想法是二维前缀和搞一下。</p><p>然而我们看到$n,m$的数据灰常大，肯定布星啊</p><p>然后我们发现$w$好像要小一点，可以离散化。</p><p>然而$w&#x3D;100000,w^2$是跑不过的还是布星啊</p><p>那肿么办？</p><p>我们把所有物品的坐标按$y$排个序，我们发现夹在两个$y$相同的物品之间的空格的左边和右边的物品是一样的，我们只需要知道他们上面和下面有多少物品即可，用线段树维护一下这一位置上面有多少个物品即可。</p><p>那我们只需要将排完序的物品扫一遍，顺便记录下这一行我们扫到了几个物品，然后对于同一行的两个物品之间的空格计算答案，最后把物品统计入线段树就$OK$辣！</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;cstring&gt;<br>#include &lt;algorithm&gt;<br>#define <span class="hljs-symbol">LL</span> long long<br>using namespace std;<br>const int <span class="hljs-symbol">N</span> = <span class="hljs-number">400010</span>;<br>const <span class="hljs-symbol">LL</span> mod = <span class="hljs-number">2147483648</span>;<br>struct ss&#123;<br><span class="hljs-symbol">LL</span> x, y;<br>&#125;;ss node[<span class="hljs-symbol">N</span>];<br><span class="hljs-symbol">LL</span> n, m;<br>int w, tot, cy, k;<br><span class="hljs-symbol">LL</span> hash[<span class="hljs-symbol">N</span>], <span class="hljs-symbol">C</span>[<span class="hljs-symbol">N</span>][<span class="hljs-number">15</span>], sumv[<span class="hljs-symbol">N</span> * <span class="hljs-number">4</span>], sumx[<span class="hljs-symbol">N</span> * <span class="hljs-number">4</span>], sumy[<span class="hljs-symbol">N</span> * <span class="hljs-number">4</span>], cx[<span class="hljs-symbol">N</span>];<br><span class="hljs-symbol">LL</span> ans;<br>int cmp(ss a, ss b)<br>&#123;<br>return (a.y &lt; b.y || (a.y == b.y &amp;&amp; a.x &lt; b.x));<br>&#125;<br>void get_C()<br>&#123;<br>for(int i = <span class="hljs-number">0</span>;i &lt;= w; ++i) <span class="hljs-symbol">C</span>[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>ll;<br>for(int i = <span class="hljs-number">1</span>;i &lt;= w; ++i)<br> for(int j = <span class="hljs-number">1</span>;j &lt;= k; ++j)<br>  <span class="hljs-symbol">C</span>[i][j] = (<span class="hljs-symbol">C</span>[i - <span class="hljs-number">1</span>][j] + <span class="hljs-symbol">C</span>[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) <span class="hljs-comment">% mod;</span><br>&#125;<br><span class="hljs-symbol">LL</span> query(int rt, int l, int r, int x, int y)<br>&#123;<br>if(l &gt;= x &amp;&amp; r &lt;= y) <br>return sumv[rt] <span class="hljs-comment">% mod;</span><br>if(x &gt; r || y &lt; l) return <span class="hljs-number">0</span>;<br><span class="hljs-symbol">LL</span> ans = <span class="hljs-number">0</span>;<br>int mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>ans = (query(rt&lt;&lt;<span class="hljs-number">1</span>, l, mid, x, y) + query(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, y)) <span class="hljs-comment">% mod;</span><br>return ans;<br>&#125;<br>void up(int rt)<br>&#123;<br>sumv[rt] = (sumv[rt&lt;&lt;<span class="hljs-number">1</span>] + sumv[rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]) <span class="hljs-comment">% mod;</span><br>&#125;<br>void update(int rt, int l, int r, int pos, <span class="hljs-symbol">LL</span> v)<br>&#123;<br>if(l == r) <br>&#123;<br>sumv[rt] = v;return;<br>&#125;<br>int mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>if(pos &lt;= mid) update(rt&lt;&lt;<span class="hljs-number">1</span>, l, mid, pos, v);<br>else update(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, pos, v);<br>up(rt);<br>&#125;<br>int main()<br>&#123;<br>scanf(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w);<br>for(int i = <span class="hljs-number">1</span>;i &lt;= w; ++i)<br>&#123;<br>scanf(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;node[i].x, &amp;node[i].y);<br>hash[++tot] = node[i].x, hash[++tot] = node[i].y;<br>&#125;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>sort(hash + <span class="hljs-number">1</span>,hash + <span class="hljs-number">1</span>+ tot);<br>int len = unique(hash + <span class="hljs-number">1</span>, hash + <span class="hljs-number">1</span> + tot) - hash - <span class="hljs-number">1</span>;n = <span class="hljs-number">0</span>;<br>for(int i = <span class="hljs-number">1</span>;i &lt;= w; ++i)<br>&#123;<br>node[i].x = lower_bound(hash + <span class="hljs-number">1</span>, hash + <span class="hljs-number">1</span> + len, node[i].x) - hash;<br>node[i].y = lower_bound(hash + <span class="hljs-number">1</span>, hash + <span class="hljs-number">1</span> + len, node[i].y) - hash;<br>n = max(n, node[i].x);<br>sumx[node[i].x] ++;<br>sumy[node[i].y] ++;<br>&#125;<br>sort(node + <span class="hljs-number">1</span>, node + <span class="hljs-number">1</span> + w, cmp);<br>get_C();<br>for(int i = <span class="hljs-number">1</span>;i &lt;= w; ++i)<br>&#123;<br><span class="hljs-symbol">LL</span> x = node[i].x, y = node[i].y;<br>if(y == node[i - <span class="hljs-number">1</span>].y &amp;&amp; i &gt; <span class="hljs-number">1</span>)<br>&#123;<br>if(node[i].x - node[i - <span class="hljs-number">1</span>].x &gt; <span class="hljs-number">1</span>)<br>ans = (ans + <span class="hljs-symbol">C</span>[cy][k] * <span class="hljs-symbol">C</span>[sumy[y] - cy][k] <span class="hljs-comment">% mod * query(1, 1, n, node[i - 1].x + 1, node[i].x - 1) % mod) % mod;</span><br>cy++;<br>&#125;<br>else cy = <span class="hljs-number">1</span>;<br>cx[x] ++;<br><span class="hljs-symbol">LL</span> v = <span class="hljs-symbol">C</span>[cx[x]][k] * <span class="hljs-symbol">C</span>[sumx[x] - cx[x]][k] <span class="hljs-comment">% mod;</span><br>update(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, v <span class="hljs-comment">% mod); </span><br>&#125;<br>printf(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>线段树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最优贸易</title>
    <link href="/2018/10/20/datbAkIOI/"/>
    <url>/2018/10/20/datbAkIOI/</url>
    
    <content type="html"><![CDATA[<h2 id="P1073-最优贸易"><a href="#P1073-最优贸易" class="headerlink" title="P1073 最优贸易"></a>P1073 最优贸易</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一张图，每个点有个点权，从起点到终点的路径上，你需要在一个点买入一个点权，再在另一个点卖出，求你的最大收益。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于如果一些点能够相互到达，那么我们能在这坨点里转转转来取到所有情况，所以我们考虑先缩点，记录每个强连通分量能取到的最小值$minv$，最大值$maxv$和最大收益$maxf$。然后我们进行拓扑排序dp。我们记$g[i]$为从起点到点$i$的最小点权，记$f[i]$为从起点到点$i$的最大收益，所以状态转移方程式为</p><blockquote><p>$g[i] &#x3D; min(g[i], g[j])$</p></blockquote><blockquote><p>$f[i] &#x3D; max(f[i], f[x],maxv[i] - g[i])$</p></blockquote><p>边界为$g[i] &#x3D; minv[i], f[i] &#x3D; maxf[i]$</p><p>其中$j$为i的前驱，采用刷表法。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;iostream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;cstring&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">N</span> = <span class="hljs-number">100010</span>;<br>const int <span class="hljs-symbol">M</span> = <span class="hljs-number">500010</span>;<br>struct ss&#123;<br>int next, to;<br>&#125;;ss data[<span class="hljs-symbol">M</span> &lt;&lt; <span class="hljs-number">1</span>];<br>int n, m, p, top, ans, times, cnt;<br>int dfn[<span class="hljs-symbol">N</span>], low[<span class="hljs-symbol">N</span>], instack[<span class="hljs-symbol">N</span>], stack[<span class="hljs-symbol">N</span>], belong[<span class="hljs-symbol">N</span>], minv[<span class="hljs-symbol">N</span>], maxv[<span class="hljs-symbol">N</span>];<br>int pu[<span class="hljs-symbol">M</span>], pv[<span class="hljs-symbol">M</span>], f[<span class="hljs-symbol">N</span>], g[<span class="hljs-symbol">N</span>], head[<span class="hljs-symbol">N</span>], val[<span class="hljs-symbol">N</span>], tmp[<span class="hljs-symbol">M</span>], du[<span class="hljs-symbol">N</span>], used[<span class="hljs-symbol">N</span>], maxf[<span class="hljs-symbol">N</span>];<br>queue&lt;int&gt;<span class="hljs-symbol">Q</span>;<br>void add(int a, int b)<br>&#123;<br>data[++p].next = head[a];<br>data[p].to = b;<br>head[a] = p;<br>&#125;<br>void tarjan(int a)<br>&#123;<br>low[a] = dfn[a] = ++times;<br>instack[a] = <span class="hljs-number">1</span>;<br>stack[++top] = a;<br>for(int i = head[a];i;i = data[i].next)<br>&#123;<br>int v = data[i].to;<br>if(!dfn[v])<br>&#123;<br>tarjan(v);<br>low[a] = min(low[a], low[v]);<br>&#125;<br>else if(instack[v])<br>low[a] = min(low[a], dfn[v]);<br>&#125;<br>if(low[a] == dfn[a])<br>&#123;<br>cnt++;<br>while(stack[top + <span class="hljs-number">1</span>] != a)<br>&#123;<br>belong[stack[top]] = cnt;<br>minv[cnt] = min(minv[cnt], val[stack[top]]);<br>maxv[cnt] = max(maxv[cnt], val[stack[top]]);<br>maxf[cnt] = max(maxf[cnt], maxv[cnt] - minv[cnt]);<br>instack[stack[top--]] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>int main()<br>&#123;<br>//freopen(<span class="hljs-string">&quot;trade.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>scanf(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>for(int i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val[i]);<br>for(int i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;pu[i], &amp;pv[i], &amp;tmp[i]);<br>add(pu[i], pv[i]);<br>if(tmp[i] == <span class="hljs-number">2</span>) add(pv[i], pu[i]);<br>&#125;<br>memset(minv, <span class="hljs-number">0x3f</span>, sizeof(minv));<br>for(int i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br>if(!dfn[i])<br>tarjan(i);<br>memset(data, <span class="hljs-number">0</span>, sizeof(data));<br>memset(head, <span class="hljs-number">0</span>, sizeof(head));p = <span class="hljs-number">0</span>;<br>for(int i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br>if(belong[pu[i]] != belong[pv[i]])<br>&#123;<br>add(belong[pu[i]], belong[pv[i]]);du[belong[pv[i]]] ++;<br>if(tmp[i] == <span class="hljs-number">2</span>) add(belong[pv[i]], belong[pu[i]]), du[belong[pu[i]]]++;<br>&#125;<br>for(int i = <span class="hljs-number">1</span>;i &lt;= cnt; ++i) g[i] = minv[i], f[i] = maxf[i];<br>for(int i = <span class="hljs-number">1</span>;i &lt;= cnt; ++i)<br>if(du[i] == <span class="hljs-number">0</span>) <span class="hljs-symbol">Q</span>.push(i), used[i] = <span class="hljs-number">1</span>;<br>while(!<span class="hljs-symbol">Q</span>.empty())<br>&#123;<br>int x = <span class="hljs-symbol">Q</span>.front();<span class="hljs-symbol">Q</span>.pop();<br>for(int i = head[x];i;i = data[i].next)<br>&#123;<br>int v = data[i].to;<br>du[v]--;<br>g[v] = min(g[v], g[x]);<br>f[v] = max(f[x], max(maxv[v] - g[v], f[v]));<br>if(du[v] == <span class="hljs-number">0</span> &amp;&amp; !used[v])<br><span class="hljs-symbol">Q</span>.push(v), used[v] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>, f[belong[n]]);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tarjan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>平衡</title>
    <link href="/2018/10/20/banlance/"/>
    <url>/2018/10/20/banlance/</url>
    
    <content type="html"><![CDATA[<h2 id="HEOI2014-平衡"><a href="#HEOI2014-平衡" class="headerlink" title="[HEOI2014]平衡"></a>[HEOI2014]平衡</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目描述<br>下课了，露露、花花和萱萱在课桌上用正三棱柱教具和尺子摆起了一个“跷跷板”。</p><p>这个“跷跷板”的结构是这样的：底部是一个侧面平行于地平面的正三棱柱教具，上面 摆着一个尺子，尺子上摆着若干个相同的橡皮。尺子有 2n + 1 条等距的刻度线，第 n + 1 条 刻度线恰好在尺子的中心，且与正三棱柱的不在课桌上的棱完全重合。</p><p>露露发现这个“跷跷板”是不平衡的（尺子不平行于地平面）。于是，她又在尺子上放 了几个橡皮，并移动了一些橡皮的位置，使得尺子的 2n + 1 条刻度线上都恰有一块相同质 量的橡皮。“跷跷板”平衡了，露露感到很高兴。</p><p>花花觉得这样太没有意思，于是从尺子上随意拿走了 k 个橡皮。令她惊讶的事情发生了： 尺子依然保持着平衡！ 萱萱是一个善于思考的孩子，她当然不对尺子依然保持平衡感到吃惊，因为这只是一个 偶然的事件罢了。令她感兴趣的是，花花有多少种拿走 k 个橡皮的方法，使得尺子依然保 持平衡？当然，为了简化问题，她不得不做一些牺牲——假设所有橡皮都是拥有相同质量的 质点。但即使是这样，她也没能计算出这个数目。放学后，她把这个问题交给了她的哥哥&#x2F; 姐姐——Hibarigasaki 学园学生会会长，也就是你。当然，由于这个问题的答案也许会过于 庞大，你只需要告诉她答案 mod p 的值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>物理太菜了，想了好一会儿才把模型建出来QAQ</p><p>其实就是说有两个序列都是1到n，你要从这两个序列中共选出k个数，使得这两个序列选出来的数的和要相等，求方案数</p><p>模型建出来后又不会做了….</p><p>其实我们可以用kiana的编故事法</p><p>现在我们有$i$个互不相同的数字，和为$j$，方案数为$f[i][j]$,现在我们有两个选择</p><ol><li><p>这$i$个数都加上1，所以转移到$f[i][j+i]$</p></li><li><p>这$i$个数都加上1，然后再加入一个数1，所以转移到$f[i + 1][j + i]$。</p></li></ol><p><del>很显然</del>这两个方法可以构造出所有合法方案。</p><p>对于这道题我们还要处理一下万一我们选的数大于了$n$怎么办？对于$f[i][j](j &gt;&#x3D;n + 1)$， 我们减去一个$f[i - 1][j - n - 1]$就行了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> T;<br><span class="hljs-type">int</span> n, k, p;<br>LL f[N * <span class="hljs-number">10</span>][<span class="hljs-number">15</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br>LL ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;p);<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br>f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n * k; ++i)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-built_in">min</span>(i, k); ++j)<br>  &#123;<br>   f[i][j] = (f[i - j][j] + f[i - j][j - <span class="hljs-number">1</span>]) % p;<br>   <span class="hljs-keyword">if</span>(i &gt;= n + <span class="hljs-number">1</span>) f[i][j] = (f[i][j] - f[i - n - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + p) % p;<br>  &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n * k; ++i)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= k; ++j)<br>     &#123;<br>     ans = (ans + f[i][j] * f[i][k - j]) % p;<br>     <span class="hljs-keyword">if</span>(j &lt; k) ans = (ans + f[i][j] * f[i][k - j - <span class="hljs-number">1</span>]);<br>     &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卡牌游戏</title>
    <link href="/2018/10/20/pai/"/>
    <url>/2018/10/20/pai/</url>
    
    <content type="html"><![CDATA[<h2 id="JLOI2013-卡牌游戏"><a href="#JLOI2013-卡牌游戏" class="headerlink" title="[JLOI2013]卡牌游戏"></a>[JLOI2013]卡牌游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>N个人坐成一圈玩游戏。一开始我们把所有玩家按顺时针从1到N编号。首先第一回合是玩家1作为庄家。每个回合庄家都会随机（即按相等的概率）从卡牌堆里选择一张卡片，假设卡片上的数字为X，则庄家首先把卡片上的数字向所有玩家展示，然后按顺时针从庄家位置数第X个人将被处决即退出游戏。然后卡片将会被放回卡牌堆里并重新洗牌。被处决的人按顺时针的下一个人将会作为下一轮的庄家。那么经过N-1轮后最后只会剩下一个人，即为本次游戏的胜者。现在你预先知道了总共有M张卡片，也知道每张卡片上的数字。现在你需要确定每个玩家胜出的概率。</p><p>这里有一个简单的例子：</p><p>例如一共有4个玩家，有四张卡片分别写着3,4,5,6.</p><p>第一回合，庄家是玩家1，假设他选择了一张写着数字5的卡片。那么按顺时针数1,2,3,4,1，最后玩家1被踢出游戏。</p><p>第二回合，庄家就是玩家1的下一个人，即玩家2.假设玩家2这次选择了一张数字6，那么2,3,4,2,3,4，玩家4被踢出游戏。</p><p>第三回合，玩家2再一次成为庄家。如果这一次玩家2再次选了6，则玩家3被踢出游戏，最后的胜者就是玩家2.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>挺好的一道概率dp题，刚了一个多小时才搞出来（状态定义太过于蛇皮）</p><p>我们定义$f[i][j]$表示在$i$个人中，从庄家顺时针数第$j$个人活下来的概率。</p><p>考虑转移。首先如果只有一个人那么很显然$f[1][1]&#x3D;1$，那么我们再考虑普通情况，我们发现$f[i][j]$中如果我们踢掉了第$x$个人，那么就会转移到$f[i-1]$的某种情况。如果$x&gt;j$，那么$j$在下一个状态的位置就会变成$i - x + j$，同理，如果&amp;x&lt;j&amp;，那么$j$在下一个状态的位置就会变成$j - x$。</p><p>那么状态转移方程可得:</p><p>$f[i][j] +&#x3D; f[i- 1][i - x + j] &#x2F; m$</p><p>$f[i][j] +&#x3D; f[i - 1][j - x]&#x2F;m$</p><p>枚举卡牌来得到x即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> db double</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">55</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> pai[N];<br>db f[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pai[i]);<br>f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n; ++i)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= i; ++j)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= m; ++k)<br>  &#123;<br>  <span class="hljs-type">int</span> c;<br>  <span class="hljs-keyword">if</span>(pai[k] % i == <span class="hljs-number">0</span>) c = i;<br>  <span class="hljs-keyword">else</span> c = pai[k] % i;<br>  <span class="hljs-keyword">if</span>(c &gt; j) f[i][j] += f[i - <span class="hljs-number">1</span>][i - c + j] / (db)(m);<br>  <span class="hljs-keyword">if</span>(c &lt; j) f[i][j] += f[i - <span class="hljs-number">1</span>][j - c] / (db)(m);<br>  &#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; ++i)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf%% &quot;</span>, f[n][i] * <span class="hljs-number">100</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概率dp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抢掠计划</title>
    <link href="/2018/10/20/qiang/"/>
    <url>/2018/10/20/qiang/</url>
    
    <content type="html"><![CDATA[<p>首先我们看见可以重复走路径，那么就想到其实这些路口可以构成一个个强连通分量（因为只要我们能到达一个强连通分量其中某一个点，那么我们就能到达这个强连通分量的其余所有点并且保证更优）。那就很容易想到缩点加最长路，至于最长路，我是把点权转移到边权，然后把边权置为负，就可以愉快的跑最短路啦</p><p>至于如何用tarjan求强联通分量，就可以来看我的博客啦(<a href="https://www.luogu.org/blog/sincereactor/">https://www.luogu.org/blog/sincereactor/</a>)</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;cstring&gt;<br>using namespace std;<br>struct ss&#123;<br>int next,to,val;<br>&#125;;ss data[<span class="hljs-number">500010</span>];<br>int head[<span class="hljs-number">200010</span>],qe[<span class="hljs-number">500010</span>],used[<span class="hljs-number">500010</span>],dis[<span class="hljs-number">500010</span>],color[<span class="hljs-number">500010</span>],sum[<span class="hljs-number">500010</span>];<br>int n,m,p,q,timeclock,ans,tot,top,<span class="hljs-symbol">S</span>,s,t,<span class="hljs-symbol">P</span>,jiu;<br>int x[<span class="hljs-number">500010</span>],y[<span class="hljs-number">500010</span>],dfn[<span class="hljs-number">500010</span>],low[<span class="hljs-number">500010</span>],instack[<span class="hljs-number">500010</span>],stack[<span class="hljs-number">500010</span>],money[<span class="hljs-number">500010</span>];<br>void add(int a,int b)//建个图跑tarjan求强连通分量<br>&#123;<br>data[++p].to=b;<br>data[p].next=head[a];<br>head[a]=p;<br>&#125;<br>void <span class="hljs-symbol">Add</span>(int a,int b,int c)//再建个图跑spfa求最长路<br>&#123;<br>data[++p].to=b;<br>data[p].next=head[a];<br>data[p].val=c;<br>head[a]=p;<br>&#125;<br>void tarjan(int a)//标准tarjan<br>&#123;<br>dfn[a]=low[a]=++timeclock;<br>instack[a]=<span class="hljs-number">1</span>;<br>stack[++top]=a;<br>for(int i=head[a];i;i=data[i].next)<br>&#123;<br>int v=data[i].to;<br>if(!dfn[v])<br>&#123;<br>tarjan(v);<br>low[a]=min(low[a],low[v]);<br>&#125;<br>else<br>if(instack[v])<br>low[a]=min(low[a],dfn[v]);<br>&#125;<br>if(dfn[a]==low[a])<br>&#123;<br>tot++;<br>while(stack[top+<span class="hljs-number">1</span>]!=a)<br>&#123;<br>color[stack[top]]=tot;<br>sum[tot]+=money[stack[top]];<br>instack[stack[top--]]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>void spfa()//标准spfa<br>&#123;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=tot;i++)<br>dis[i]=<span class="hljs-number">0x7fffffff</span>;<br>int ts=color[<span class="hljs-symbol">S</span>];<br>dis[ts]=-sum[ts];<br>qe[<span class="hljs-number">0</span>]=ts;p=q=<span class="hljs-number">0</span>;<br>while(p&lt;=q)<br>&#123;<br>s=qe[p<span class="hljs-comment">%n];</span><br>used[s]=<span class="hljs-number">0</span>;<br>t=head[s];<br>while(t)<br>&#123;<br>if(dis[s]+data[t].val&lt;dis[data[t].to])<br>&#123;<br>dis[data[t].to]=dis[s]+data[t].val;<br>if(!used[data[t].to])<br>&#123;<br>qe[++q<span class="hljs-comment">%n]=data[t].to;</span><br>used[data[t].to]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>t=data[t].next;<br>&#125;<br>p++;<br>&#125;<br>&#125;<br>int main()<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);<br>    add(x[i],y[i]);<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;money[i]);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>if(!dfn[i])<br>&#123;<br>   tarjan(i);<br>    &#125;<br>memset(data,<span class="hljs-number">0</span>,sizeof(data));<br>memset(head,<span class="hljs-number">0</span>,sizeof(head));<br>p=<span class="hljs-number">0</span>;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>if(color[x[i]]!=color[y[i]])<br><span class="hljs-symbol">Add</span>(color[x[i]],color[y[i]],-(sum[color[y[i]]]));<br>&#125;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;<span class="hljs-symbol">S</span>);<br>spfa();<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;<span class="hljs-symbol">P</span>);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-symbol">P</span>;i++)//把所有酒吧看一遍，求个最大<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;jiu);<br>if(-dis[color[jiu]]&gt;ans)<br>ans=-dis[color[jiu]];<br>&#125;<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tarjan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>间谍网络</title>
    <link href="/2018/10/20/spy/"/>
    <url>/2018/10/20/spy/</url>
    
    <content type="html"><![CDATA[<h3 id="可以看出此题有两种情况"><a href="#可以看出此题有两种情况" class="headerlink" title="可以看出此题有两种情况:"></a>可以看出此题有两种情况:</h3><p>一是有的罪犯既不能贿赂他也没有罪犯能揭发他，那么此题无解，我们在遍历时打上标记，然后从小到大枚举，只要遇见没有标记的就输出然后退出即可</p><p>二是所有的罪犯都能直接或间接地被能贿赂的罪犯揭发。很明显，也有两种情况，一是没有环，那么资金就是贿赂那个没有入度的罪犯，二是有环，那么资金就是那个环里罪犯所需资金最小的。我们想，如果我们把环里的罪犯缩成一个点，那么全都是前者的情况了</p><p>至于如何缩点欢迎来看<a href="https://www.luogu.org/blog/sincereactor/">我的博客</a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;cstring&gt;<br>using namespace std;<br>struct ss&#123;<br>int next,to;<br>&#125;;ss data[<span class="hljs-number">200010</span>];<br>const int inf=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>int n,q,timeclock,p,top,cnt,ans,r;<br>int dfn[<span class="hljs-number">200010</span>],low[<span class="hljs-number">200010</span>],stack[<span class="hljs-number">200010</span>],instack[<span class="hljs-number">200010</span>],next[<span class="hljs-number">200010</span>],head[<span class="hljs-number">200010</span>];<br>int belong[<span class="hljs-number">200010</span>],money[<span class="hljs-number">200010</span>],sum[<span class="hljs-number">200010</span>],size[<span class="hljs-number">200010</span>],rd[<span class="hljs-number">200010</span>];<br>void add(int a,int b)<br>&#123;<br>data[++p].next=head[a];<br>data[p].to=b;<br>head[a]=p;<br>&#125;<br>void tarjan(int a)           //标准的tarjan代码 <br>&#123;<br>dfn[a]=low[a]=++timeclock;<br>instack[a]=<span class="hljs-number">1</span>;<br>stack[++top]=a;<br>for(int i=head[a];i;i=data[i].next)<br>&#123;<br>int v=data[i].to;<br>    if(!dfn[v])<br>    &#123;<br>     tarjan(v);<br>    low[a]=min(low[a],low[v]);<br>    &#125;<br>    else<br>    if(instack[v])<br>    low[a]=min(low[a],dfn[v]);<br>&#125;<br>if(dfn[a]==low[a])<br>&#123;<br>cnt++;<br>while(stack[top+<span class="hljs-number">1</span>]!=a)<br>&#123;<br>belong[stack[top]]=cnt;<br>instack[stack[top]]=<span class="hljs-number">0</span>;<br>size[cnt]++;<br>sum[cnt]=min(sum[cnt],money[stack[top]]);<br>top--;<br>&#125;<br>&#125;<br>&#125;<br>int main()<br>&#123;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>money[i]=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;        //记得赋初值哦 <br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>sum[i]=<span class="hljs-number">1e9</span>;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=q;i++)<br>&#123;<br>int u,mo;<br>scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;mo);<br>money[u]=mo;<br>&#125;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;r);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=r;i++)<br>&#123;<br>int u,v;<br>scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>add(u,v);<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>if(!dfn[i]&amp;&amp;money[i]!=inf)  //如果他能够被贿赂就以他为起点找环 <br>tarjan(i);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)      //在这里我们用dfn数组来判断它是否被遍历过 <br>if(!dfn[i])<br>&#123;<br>printf(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>return <span class="hljs-number">0</span>;<br>&#125;<br><br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>for(int j=head[i];j;j=data[j].next)<br>if(belong[i]!=belong[data[j].to])<br>&#123;<br>    rd[belong[data[j].to]]++;   //记录入度 <br>&#125;<br>printf(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>for(int i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>&#123;<br>   if(!rd[i])<br>   &#123; <br>       ans+=sum[i];<br>   &#125;<br>    &#125;<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tarjan</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树上差分</title>
    <link href="/2018/10/20/ys/"/>
    <url>/2018/10/20/ys/</url>
    
    <content type="html"><![CDATA[<p>好久没写博客了（主要是博主太弱全在学习），今天发现了个<del>很有意思的东东</del>，但炒鸡好用。于是，便把这位仁兄记录了下来。没错，他就是——树上差分。</p><p>先摆一波题</p><p><a href="https://www.luogu.org/problemnew/show/P1600">天天爱跑步</a>；</p><p><a href="https://www.luogu.org/problemnew/show/P2680">运输计划</a>；</p><p><a href="https://www.luogu.org/problemnew/show/P1084">疫情控制</a>；</p><p><a href="https://www.luogu.org/problemnew/show/P3258">松鼠的新家</a>；</p><p>一堆noip的难题由此诞生。</p><p>好了，四不四已经跃跃欲试了呢？让我们先看一下</p><h2 id="差分为何物。"><a href="#差分为何物。" class="headerlink" title="差分为何物。"></a>差分为何物。</h2><p>放一个水题：</p><pre><code class="hljs"> “给你一个m×n的矩阵，然后使用k块地毯铺地。每片地毯都给出左下角和右上角坐标。问所有地毯铺完之后，还有多少个整点（所谓整点，即横、纵坐标均为整数的点）没有被地毯覆盖。”</code></pre><p>想到暴力：1.暴力枚举每张地毯</p><p> 2.将所有被覆盖的点均做上标记</p><p>  3.最后再枚举所有整点，若未被标记则ans+1；</p><p>然而时间复杂度是O（mnk）的，直接超时。</p><p>竟然有人想用线段树？太强了，考场祝您一路顺风。</p><p>考虑差分</p><p><img src="https://s1.ax1x.com/2018/10/20/iBSzss.png" alt="iBSzss.png"></p><p>用前缀和的方式进行维护，比如我们覆盖了2到5.</p><p><img src="https://s1.ax1x.com/2018/10/20/iBpMo6.png" alt="iBpMo6.png"></p><p>在2那里加上1，那么2之后的前缀和就都是1（表示覆盖）了。</p><p>然而我们要找的是2到5，不是2以后，所以在6那里要减1。</p><p><img src="https://s1.ax1x.com/2018/10/20/iBpCd0.png" alt="iBpCd0.png"></p><p>所以我们要求的前缀和</p><p><img src="https://s1.ax1x.com/2018/10/20/iBpPoV.png" alt="iBpPoV.png"></p><p>完美解决</p><p>让我们考虑树上差分</p><h2 id="一-关于边的差分（如找被所有路径共同覆盖的边）"><a href="#一-关于边的差分（如找被所有路径共同覆盖的边）" class="headerlink" title="一.关于边的差分（如找被所有路径共同覆盖的边）"></a>一.关于边的差分（如找被所有路径共同覆盖的边）</h2><p>首先我们除了一般的grand，depth等数组以外，多开两个数组：tmp和prev。</p><p>tmp用来记录点的出现次数（具体点说实际上记录的是点到其父亲的边的出现次数），prev记录每个点到其父亲的那条边。对于一条起点s，终点t的路径。我们这样处理：</p><p>tmp[s]++,tmp[t]++,tmp[LCA(s,t)]-&#x3D;2。（记住：最后要从所有叶结点把权值向上累加。）以一次操作为例，我们来看看效果（可以画一张图）。首先tmp[s]++，一直推上去到根，这时候s到root的路径访问次数都+1，tmp[t]++后，t到lca路径加了1，s到lca路径加了1，而lca到根的路径加了2。</p><p>这时，我们只需要tmp[LCA(s,t)]-&#x3D;2，推到根，就能把那些多余的路径减掉，达到想要的目的。而这是一次操作，对于很多次操作的话，我们只需要维护tmp，而不必每次更新到根，维护好tmp最后Dfs一遍即可。这时如果tmp[i]&#x3D;&#x3D;次数的话，说明i到其父亲的边是被所有路径覆盖的。如图</p><p><img src="https://s1.ax1x.com/2018/10/20/iBpSLn.png" alt="iBpSLn.png"></p><p>放一个例题代码：运输计划</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;stdio.h&gt;</span><br><span class="hljs-comment">#include&lt;cstring&gt;</span><br>using namespace std;<br>struct ss&#123;<br>    int next,<span class="hljs-keyword">to</span>,val;<br>&#125;;ss data[600010];<br>struct truck&#123;<br>    int s,t,lca;<br>&#125;;truck node[300010];<br>int n,m,p,flag,cnt,maxn;<br>int head[300010],deep[300010],f[300010][25],dis[300010],pre[300010],sum[300010];<br>void change(int &amp;a,int &amp;b)<br>&#123;<br>    int <span class="hljs-attribute">t</span>=a;a=b;b=t;<br>&#125;<br>void <span class="hljs-built_in">add</span>(int a,int b,int c)<br>&#123;<br>    data[++p].<span class="hljs-attribute">to</span>=b;<br>    data[p].<span class="hljs-attribute">next</span>=head[a];<br>    data[p].<span class="hljs-attribute">val</span>=c;<br>    head[a]=p;<br>&#125;<br>void dfs(int a,int fa)<br>&#123;<br>    deep[a]=deep[fa]+1;<br>    f[a][0]=fa;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=20;i++)<br>    f[a][i]=f[f[a][i-1]][i-1];<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[a];i;<span class="hljs-attribute">i</span>=data[i].next)<br>    &#123;<br>        int <span class="hljs-attribute">v</span>=data[i].<span class="hljs-keyword">to</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">v</span>==fa) continue;<br>        dis[v]=dis[a]+data[i].val;<br>        pre[v]=data[i].val;<br>        dfs(v,a);<br>    &#125;<br>&#125;<br>int getlca(int a,int b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(deep[a]&gt;deep[b]) change(a,b);<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=20;i&gt;=0;i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(deep[a]&lt;=deep[f[b][i]])<br>        <span class="hljs-attribute">b</span>=f[b][i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">a</span>==b) return a;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=20;i&gt;=0;i--)<br>    <span class="hljs-keyword">if</span>(f[a][i]!=f[b][i])<br>    &#123;<br>        <span class="hljs-attribute">a</span>=f[a][i];<br>        <span class="hljs-attribute">b</span>=f[b][i];<br>    &#125;<br>    return f[a][0];<br>&#125;<br>int judge(int a,int fa,int cnt,int maxn)<br>&#123;<br>    int <span class="hljs-attribute">nsum</span>=sum[a];<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[a];i;<span class="hljs-attribute">i</span>=data[i].next)<br>    &#123;<br>        int <span class="hljs-attribute">v</span>=data[i].<span class="hljs-keyword">to</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">v</span>==fa) continue;<br>        nsum+=judge(v,a,cnt,maxn); <br>    &#125;<br>    <span class="hljs-keyword">if</span>(nsum&gt;=cnt&amp;&amp;pre[a]&gt;=maxn) <span class="hljs-attribute">flag</span>=1;<br>    return nsum;<br>&#125;<br>int check(long long limit)<br>&#123;<br>    memset(sum,0,sizeof(sum));<br>    <span class="hljs-attribute">cnt</span>=0,flag=0,maxn=0;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=m;i++)<br>    <span class="hljs-keyword">if</span>(dis[node[i].s]+dis[node[i].t]-2<span class="hljs-number">*d</span>is[node[i].lca]&gt;limit)<br>    &#123;<br>        sum[node[i].s]++,sum[node[i].t]++,sum[node[i].lca]<span class="hljs-attribute">-</span>=2;<br>        cnt++;<br>        <span class="hljs-attribute">maxn</span>=max(maxn,dis[node[i].s]+dis[node[i].t]-2<span class="hljs-number">*d</span>is[node[i].lca]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">cnt</span>==0) return 1;<br>    int <span class="hljs-attribute">wsb</span>=judge(1,0,cnt,maxn-limit);<br>    return flag;<br>&#125;<br>int main()<br>&#123;<br>    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n-1;i++)<br>    &#123;<br>        int a,b,c;<br>        scanf(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    dfs(1,0);<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=m;i++)<br>    &#123;<br>        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;node[i].s,&amp;node[i].t);<br>        node[i].<span class="hljs-attribute">lca</span>=getlca(node[i].s,node[i].t);<br>    &#125;<br>    long long <span class="hljs-attribute">l</span>=0,r=3000000000;<br>    <span class="hljs-keyword">while</span>(l+1&lt;r)<br>    &#123;<br>        int mid=(l+r)/2;<br>        <span class="hljs-keyword">if</span>(check(mid)) <span class="hljs-attribute">r</span>=mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-attribute">l</span>=mid;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(check(l)) printf(<span class="hljs-string">&quot;%lld\n&quot;</span>,l);<br>    <span class="hljs-keyword">else</span> printf(<span class="hljs-string">&quot;%lld\n&quot;</span>,r);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-关于点的差分（如将路径上的所有点权值加一，求最后点的权值）"><a href="#二-关于点的差分（如将路径上的所有点权值加一，求最后点的权值）" class="headerlink" title="二.关于点的差分（如将路径上的所有点权值加一，求最后点的权值）"></a>二.关于点的差分（如将路径上的所有点权值加一，求最后点的权值）</h2><p>此操作中我们这样维护：每次经过一条边，（如从u到v）我们让tmp[u]++,tmp[v]++,tmp[LCA(u,v)]–,tmp[grand[LCA(u,v)][0]]–。（最后要把tmp推上去）</p><p>以一次添加为例想象一下，首先u到根的路径上tmp都+1，此时u到根间结点tmp都为1，之后v到根路径上tmp+1，此时u到LCA前一个，v到LCA前一个点的tmp都+1，而LCA到根的所有点都+2，然后从tmp[LCA]–,更新上去，此时u-v路上所有tmp都+1，已经达到目的。</p><p>而多余的是什么部分呢，也就是LCA的上一个结点（grand[LCA][0]）到根的这一段都多加了1，所以tmp[grand[LCA][0]]–,更新上去，也就完成了。</p><p>实际操作时也不需要每次更新都推上去，只要把四个tmp维护好，最后Dfs走一边就更新完了。</p><p><img src="https://s1.ax1x.com/2018/10/20/iBp9Zq.png" alt="iBp9Zq.png"></p><p>放一个例题代码：松鼠的新家</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>#include&lt;stdio.h&gt;<br>using namespace std;<br>struct ss&#123;<br>    int next,to;<br>&#125;;ss data[<span class="hljs-number">600010</span>];<br>int n,q;<br>int a[<span class="hljs-number">300010</span>],head[<span class="hljs-number">600010</span>],deep[<span class="hljs-number">300010</span>],p[<span class="hljs-number">300010</span>][<span class="hljs-number">25</span>],sum[<span class="hljs-number">300010</span>];<br>void change(int &amp;a,int &amp;b)<br>&#123;<br>    int t=a;a=b;b=t;<br>&#125;<br>void add(int a,int b)<br>&#123;<br>    data[++q].to=b;<br>    data[q].next=head[a];<br>    head[a]=q;<br>&#125;<br>void dfs(int a,int fa)<br>&#123;<br>    deep[a]=deep[fa]+<span class="hljs-number">1</span>;<br>    p[a][<span class="hljs-number">0</span>]=fa;<br>    for(int i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=deep[a];i++)<br>    p[a][i]=p[p[a][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    for(int i=head[a];i;i=data[i].next)<br>    &#123;<br>        int v=data[i].to;<br>        if(v!=fa)<br>        dfs(v,a);<br>    &#125;<br>&#125;<br>int lca(int a,int b)<br>&#123;<br>    if(deep[a]&gt;deep[b]) change(a,b);<br>    for(int i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        if(deep[a]&lt;=deep[b]-(<span class="hljs-number">1</span>&lt;&lt;i))<br>        &#123;<br>            //printf(<span class="hljs-string">&quot;a=%d %d %d\n&quot;</span>,a,b,i);<br>            b=p[b][i];<br>        &#125;<br>    &#125;<br>    //printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,a,b);<br>    if(a==b) return a;<br>    for(int i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        if(p[a][i]!=p[b][i])<br>        a=p[a][i],b=p[b][i];<br>    &#125;<br>    //printf(<span class="hljs-string">&quot;a=%d\n&quot;</span>,a);<br>    return p[a][<span class="hljs-number">0</span>];<br>&#125;<br>void search(int a)<br>&#123;<br>    for(int i=head[a];i;i=data[i].next)<br>    &#123;<br>        int v=data[i].to;<br>        if(v==p[a][<span class="hljs-number">0</span>]) continue;<br>        search(v);<br>        sum[a]+=sum[v];<br>    &#125;<br>&#125;<br>int main()<br>&#123;<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        int u,v;<br>        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        add(u,v);add(v,u);<br>    &#125;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        int x=a[i],y=a[i+<span class="hljs-number">1</span>],<span class="hljs-symbol">LCA</span>=lca(x,y);<br>        //printf(<span class="hljs-string">&quot;lca=%d\n&quot;</span>,<span class="hljs-symbol">LCA</span>);<br>        sum[x]++;<br>        sum[y]++;<br>        sum[<span class="hljs-symbol">LCA</span>]--;<br>        sum[p[<span class="hljs-symbol">LCA</span>][<span class="hljs-number">0</span>]]--;<br>    &#125;<br>    search(<span class="hljs-number">1</span>);<br>    for(int i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    sum[a[i]]--;<br>    <br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,sum[i]);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性同余方程</title>
    <link href="/2018/10/20/ysj/"/>
    <url>/2018/10/20/ysj/</url>
    
    <content type="html"><![CDATA[<h2 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h2><p>我们要解下面的方程</p><blockquote><p>$ax\equiv c(mod \quad b)$</p></blockquote><p>我们可以将其转化为</p><blockquote><p>$ax-by &#x3D; c$</p></blockquote><p>然后我们可以开始求解上面的方程，步骤如下：</p><ol><li>令$d &#x3D; gcd(a,b)$，若$c$不能整除$d$，则原方程无整数解，否则将方程化简为$ax_0-by_0 &#x3D; c_0$。</li><li>用扩展欧几里得算法求出方程$ax_0-by_0 &#x3D; c_0$的一组特解$x_0,y_0$。</li><li>记$k &#x3D; c&#x2F;d$，则原方程$x,y$的通解为</li></ol><blockquote><p>$x &#x3D; k \times  x_0 + t \times b &#x2F; d$</p></blockquote><blockquote><p>$y &#x3D; k \times y_0 + t \times a &#x2F; d (t &#x3D; 1, 2,3,4….)$</p></blockquote><p>例题：见青蛙的约会</p><h2 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h2><p>先讲个故事</p><blockquote><p>八卦记者想知道洛阳枫有多少个女朋友，洛阳枫十分神秘地告诉他：“我的女朋友啊，3个3个地数剩2个，5个5个地数剩3个，7个7个地数剩2个。”请问洛阳枫到底最少有几个女朋友？</p></blockquote><p>那么我们可以列出方程</p><blockquote><p>$x \equiv2(mod \quad 3)$</p></blockquote><blockquote><p>$x \equiv3(mod \quad 5)$</p></blockquote><blockquote><p>$x \equiv2(mod \quad 7)$</p></blockquote><p>那我们怎么解？（暴力枚举的请走开）</p><p>首先我们先知道，如果我们得到了一个特解$x$，那么我们就可以得到最小解为$x % lcm(3, 5, 7)$。</p><p>那么我们怎么搞到一个解呢？</p><p>我们再知道如果有$k_1\equiv0(mod \quad a), k2 \equiv b(mod \quad a)$，那么$k1+k2 \equiv b(mod \quad a)$，有什么用呢？比如说我们现在有一个数$k$它满足$k% 7 &#x3D;2$，那么我们再加一个能被7整除的数也是满足的。</p><p>那到底要干什么呢？也就是说我们对于每一个方程我们都可以构造一个解使其能整除其他方程的余数，这样它便满足我们上面说的那个性质。</p><p>还是不懂？</p><p>我们举个栗子，对于第一个方程我们构造满足上面规则的最小解，它既是$5,7$的最小公倍数，又满足方程$1$，他是多少呢？35。</p><p>那么我们依葫芦画瓢，就可以得到三个方程的特解$35,63,30$，那么我们把这三个值加起来就是原方程组的一个特解$128$，我们代进去发现是满足的，<del>但洛阳枫怎么会有这么多女朋友</del>，于是我们减去三个余数的最小公倍数依旧是满足的。$128-lcm(3,5,7) &#x3D; 23$（<del>好像还是有点多</del>）</p><p>那么我们考虑一个比较普遍的情况</p><p>现在我们有$n$多个上面的方程，怎么办？</p><p>比如</p><blockquote><p>$x_1 \equiv a_1(mod \quad b_1)$</p></blockquote><blockquote><p>$x_2 \equiv a_2(mod \quad b_2)$</p></blockquote><blockquote><p>$x_3 \equiv a_3(mod \quad b_3)$</p></blockquote><blockquote><p>$x_4 \equiv a_4(mod \quad b_4)$</p></blockquote><blockquote><p>…..</p></blockquote><blockquote><p>$x_i \equiv a_i(mod \quad b_i)$</p></blockquote><h3 id="先考虑两两互质的情况"><a href="#先考虑两两互质的情况" class="headerlink" title="先考虑两两互质的情况"></a>先考虑两两互质的情况</h3><p>我们还是考虑上面的方法</p><p>我们还是构造一个解是每个方程特解的和，那么我们可以把解这样表示：</p><blockquote><p>$k_1 \times lcm &#x2F; b_1 + k_2 \times lcm &#x2F; b_2 + ….k_i \times lcm &#x2F; b_i$</p></blockquote><p>其中</p><blockquote><p>$k_i * lcm &#x2F; b_i \equiv a_i(mod \quad b_i)$</p></blockquote><p>为什么我们可以这样表示？</p><p>我们可以从之前的那个故事可以看出一些端倪，由于满足$k_i \times lcm &#x2F; b_i \equiv a_i(mod \quad b_i)$，所以当前方程的解$k_i * lcm &#x2F; b_i$是满足当前方程的，而其他方程的解一定是整除$b_i$的，加起来一定满足当前方程。所以整个方程的解是满足每个方程的。</p><p>那我们再考虑怎么解上面的方程：</p><p>我们先令$m_i &#x3D; lcm &#x2F; b_i$</p><p>方程化为：$k_i * m_i \equiv a_i(mod \quad b_i)$</p><p>我们想如果存在$k * m_i \equiv 1(mod \quad b_i)$</p><p>那么$k_i $就等于 $k * a_i$</p><p>那问题就转化为求解方程$k * m_i \equiv 1(mod \quad b_i)$</p><p>其实就是求逆元，用exgcd搞一下就行了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">25</span>;<br>LL A[N], B[N];<br><span class="hljs-type">int</span> k;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>&#123;<br>x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">ex_gcd</span>(b, a % b, y, x);<br>y -= a / b * x;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">mul</span><span class="hljs-params">(LL x, LL y, LL mod)</span>  <span class="hljs-comment">//快速乘防止毒瘤出题人 </span></span><br><span class="hljs-function"></span>&#123;<br>LL ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;y;y &gt;&gt;= <span class="hljs-number">1</span>, x = (x + x) % mod) <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans = (ans + x) % mod;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL re = <span class="hljs-number">0</span>, lcm = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= k; ++i) lcm *= B[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= k; ++i)<br>&#123;<br>LL a = lcm / B[i], x, y;<br><span class="hljs-built_in">ex_gcd</span>(a, B[i], x, y);<br>x = (x % B[i] + B[i]) % B[i];<br>re = (re + <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">mul</span>(A[i], x, lcm), a, lcm)) % lcm;<br>&#125;<br><span class="hljs-keyword">return</span> re;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= k; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;A[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= k; ++i)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;B[i]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= k; ++i)<br>A[i] = (A[i] % B[i] + B[i]) % B[i];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">work</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模方程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
